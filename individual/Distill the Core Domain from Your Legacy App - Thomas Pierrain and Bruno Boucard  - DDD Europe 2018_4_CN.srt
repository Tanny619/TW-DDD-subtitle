1
01:25:53,670 --> 01:26:04,620
那么下面是一个简短的关于聚合根的分享

2
01:26:04,620 --> 01:26:09,000
是的, 一个简短的分享. 聚合是一组实体或值对象的集合

3
01:26:09,000 --> 01:26:16,220
被当成是一个概念上的整体. 之前的例子中可以看出一些聚合的存在吗?

4
01:26:18,460 --> 01:26:30,470
火车? 对. 那么车厢是一个聚合吗? 不是
为什么呢? [因为它是火车座位的一部分,是不可变的] 是的, 一些聚合是可变的

5
01:26:30,470 --> 01:26:34,490
事实上它不是聚合, 因为聚合需要不变量, 需要业务规则

6
01:26:36,800 --> 01:26:42,560
还需要被强制执行
在我们的例子中

7
01:26:42,560 --> 01:26:49,130
唯一的可变量就是火车这一层

8
01:26:49,130 --> 01:26:53,600
业务的约束就是不能预定超过70%的火车票

9
01:26:53,600 --> 01:27:01,130
而在这个聚合里的车厢是被强约束的

10
01:27:01,130 --> 01:27:05,210
当我们和领域专家讨论的时候, 他告诉我们他希望添加一些新的关于车厢的规则

11
01:27:05,210 --> 01:27:11,000
像车厢不能够被完全订满, 以及不能超出给定的承载量

12
01:27:11,000 --> 01:27:15,980
如果是这种情况的话它就会成为一个聚合根
这些过于细节了

13
01:27:15,980 --> 01:27:22,850
但有趣的是, 火车 车厢和座位可能都是值对象

14
01:27:22,850 --> 01:27:28,760
像我们之前讨论的一样, 如果我去思考我们和外界后台系统交互的模式

15
01:27:28,760 --> 01:27:33,850
我们得到了一个在一段时间有效的快照

16
01:27:33,850 --> 01:27:40,280
我们也将会对此快照进行操作. 我们并不想将它们保存的缓存中
我们想直接操作那些聚合

17
01:27:43,340 --> 01:27:49,880
所以为了确保它, 我们可以将所有的对象都变成值对象

18
01:27:49,880 --> 01:27:53,090
实际上在现实项目的实现中我们是这样做的

19
01:27:53,090 --> 01:28:03,080
所以这意味着一些聚合可能全是值对象, [Audience]

20
01:28:03,080 --> 01:28:10,430
你是说这里的火车吗? 大部分情况下是的

21
01:28:10,430 --> 01:28:15,340
这里是一个特例[Audience]

22
01:28:27,380 --> 01:28:32,519
如果我们在车厢这一层有业务规则的约束的话

23
01:28:32,519 --> 01:28:37,289
是的, 在更详尽的版本里我们是这么设计的
那么到现在为止我们对Web ticket manager进行了改进

24
01:28:39,300 --> 01:28:45,179
之前的Reserve方法有几个屏幕的长度 
到处都是无用的遗留的逻辑

25
01:28:45,179 --> 01:28:50,880
我想我们完成了一定程度的改善, 现在这个方法只有一屏幕的长度

26
01:28:50,880 --> 01:28:56,309
代码使用了领域的词汇来命名
我们称之为通用语言

27
01:28:56,309 --> 01:29:02,130
我们提出一些行为逻辑
并把它们放到了合理的地方

28
01:29:02,130 --> 01:29:07,769
但还有一些地方让我们不爽
也就是我们之前说到的

29
01:29:07,769 --> 01:29:15,959
这里返回了json格式的
在这个领域方法里返回了可恶的json

30
01:29:15,959 --> 01:29:22,110
我们这里的返回值还是string的task对象 
也是一个json 是的

31
01:29:22,110 --> 01:29:28,380
所以我们想做的是干掉这个设计
 用Reserve来替代它

32
01:29:28,380 --> 01:29:35,579
对不起, 是Reservation
那么Reserve方法就可以返回一个Reservation

33
01:29:35,579 --> 01:29:41,249
然后, 在基础设施层
如果有适配器之类的话

34
01:29:41,249 --> 01:29:45,989
我们会把reservation转换成json的形式

35
01:29:45,989 --> 01:29:50,340
现在我觉得我们可以分享下面部分的内容

36
01:29:50,340 --> 01:29:52,979
抱歉

37
01:29:52,979 --> 01:30:00,179
我会继续重构这个代码, 你可能看不到过程
但我们一会儿会回到代码来解释

38
01:30:00,179 --> 01:30:04,380
我们的架构以及我们做了一些什么

39
01:30:04,380 --> 01:30:10,590
好的
那么谁听说过六边形架构?

40
01:30:10,590 --> 01:30:18,420
好的, 太棒了
六边形架构是由

41
01:30:18,420 --> 01:30:24,090
Alistair Cockburn提出的
我记不清了, 大概是很久之前

42
01:30:24,090 --> 01:30:28,940
它有很多的优点. 它是一个架构级的设计模式
它以拥抱变化著称

43
01:30:33,620 --> 01:30:40,370
Alistair最初的想法是可以做到插入和移除依赖

44
01:30:40,370 --> 01:30:46,460
插入和移除一些东西. 他探讨了关于系统是否应该
被插入很多的依赖作为输入

45
01:30:46,460 --> 01:30:51,260
以及很多依赖作为输出

46
01:30:51,260 --> 01:30:56,780
将新闻广播出去, 广播到电视, 广播到任意媒介
所以内部的代码是相对整洁的

47
01:31:00,830 --> 01:31:07,220
每一个对于I/O或系统交互的修改

48
01:31:07,220 --> 01:31:12,290
都不是一个event, 而是一些可以随时插入或移除的东西

49
01:31:12,290 --> 01:31:17,900
就是这么简单. 所以这个架构就是基于这种思想被提出的

50
01:31:17,900 --> 01:31:25,040
但当我们思考如何使用它的时候, 我们首先会想到

51
01:31:25,040 --> 01:31:30,320
在领域内部使代码更有业务价值

52
01:31:30,320 --> 01:31:36,310
保护我们的领域代码不受技术性的代码的影响. 
我不知道你们是怎么想的

53
01:31:36,310 --> 01:31:40,790
在过去很长时间, 我觉得几乎不可能合理地

54
01:31:40,790 --> 01:31:46,070
分离业务逻辑和技术性支撑代码. 
我们尝试过很多次以后似乎我理解了这个模式

55
01:31:46,070 --> 01:31:51,880
它是一种非常棒的解决方案

56
01:31:51,880 --> 01:31:56,330
我还希望保证可测试性,
正是因为所有的东西都是可插入可移除的

57
01:31:56,330 --> 01:32:02,150
因此我们可以采用stub, 我们可以采用mock

58
01:32:02,150 --> 01:32:07,730
我们可以stub系统的输入和输出, 内部的系统逻辑

59
01:32:07,730 --> 01:32:12,350
今天我们会更多地关注如何保护我们的领域代码
那么它是怎么工作的呢?

60
01:32:12,350 --> 01:32:16,460
将我们的世界想象成两个部分
内部和外部

61
01:32:16,460 --> 01:32:21,440
非常简单对吧? 
没有几千个层级

62
01:32:21,440 --> 01:32:27,410
非常简单, 两个部分  内部是我们的领域代码
比如Reserve方法, 比如Train

63
01:32:27,410 --> 01:32:30,680
比如ReservationAttempt之类的

64
01:32:30,680 --> 01:32:36,560
基础设施代码则在我们系统的外部

65
01:32:36,560 --> 01:32:39,710
这里可能有你喜爱的HTTP工具类

66
01:32:39,710 --> 01:32:43,520
你的数据库引擎, 你的消息中间件
你最喜欢的各种解决方案等等

67
01:32:43,520 --> 01:32:47,110
这就是基础设施的部分
我们想做的第一步是优化我们的业务代码

68
01:32:50,390 --> 01:32:56,390
首先我们希望给内部领域代码加一个带刺的铁丝网

69
01:32:56,390 --> 01:33:03,080
定义一些入口和出口

70
01:33:03,080 --> 01:33:08,810
因此可以让基础设施代码留在另外一端

71
01:33:08,810 --> 01:33:15,860
这实际上是一个非常好的能力
因为可能在开始你的程序员生涯的时候

72
01:33:17,660 --> 01:33:21,260
你需要提高你的技能, 你需要尝试新鲜的东西
你需要犯很多的错误

73
01:33:21,260 --> 01:33:26,270
你需要为了某些目的实现自己的框架

74
01:33:26,270 --> 01:33:30,140
到某一时刻,你会开始意识到自己做过一些愚蠢的事情
像实现自己的框架之类的

75
01:33:30,140 --> 01:33:36,230
但是在你真正开始关注领域之前
对一些年轻的程序员来说

76
01:33:38,750 --> 01:33:43,370
确实需要一个练手的地方
我很认同这件事

77
01:33:43,370 --> 01:33:48,500
只要它不会破坏业务逻辑和项目

78
01:33:48,500 --> 01:33:51,800
如果是这样的话, 我完全没问题
 因为这个区域是你可以练习的地方

79
01:33:51,800 --> 01:33:56,180
在基础设施代码这里就是一个练手的地方
你可以尝试新技术, 新东西

80
01:33:56,180 --> 01:34:01,130
而且不会破坏业务代码
这是我非常喜欢这个模式的地方

81
01:34:01,130 --> 01:34:05,719
那么它是如何工作的
因为有铁丝网

82
01:34:05,719 --> 01:34:09,560
但我需要进入或离开这个建筑
也就是跳出领域代码

83
01:34:09,560 --> 01:34:13,880
所以, 为了解除依赖
所有的依赖都是朝向内部的

84
01:34:13,880 --> 01:34:17,330
基础设施代码知道业务代码的存在
并可以调用它们

85
01:34:17,330 --> 01:34:22,489
但业务代码不会意识到使用了哪种框架

86
01:34:22,489 --> 01:34:29,110
即使是关于json的东西所以业务领域是完全独立于任何一种技术的

87
01:34:29,110 --> 01:34:36,770
即使是json字符串或类似的东西

88
01:34:36,770 --> 01:34:42,800
所以让我们能够从内部访问到外部的新东西

89
01:34:42,800 --> 01:34:47,870
和外部的web api交互
 我们是基于端口和适配器的

90
01:34:47,870 --> 01:34:53,180
为了实现此目的我们采用的是依赖注入原则

91
01:34:53,180 --> 01:34:58,160
所以从内部我们可以对外部进行操作

92
01:34:58,160 --> 01:35:04,130
Alistair Cockbrun最近和另外一个人的讨论

93
01:35:04,130 --> 01:35:07,910
我记不清名字了
他们提出了configurable dependencies

94
01:35:07,910 --> 01:35:12,920
Alistair提出的
dependency injection principle

95
01:35:12,920 --> 01:35:17,840
我不是十分的认同, 因为它是一种被动的规范方法

96
01:35:17,840 --> 01:35:23,900
我们都很习惯于这样做, 习惯于反转
所以他用一种更直接表达意图的方式来描述它

97
01:35:27,080 --> 01:35:32,660
因此称为了configurable dependencies
用来插入和移除你的业务代码的依赖

98
01:35:32,660 --> 01:35:41,420
所以我们回到刚才的例子

99
01:35:41,420 --> 01:35:47,420
我们说我们已经有了领域的入口的出口

100
01:35:47,420 --> 01:35:52,550
端口是属于领域的
这里有一些接口,像棒棒糖形状的图形这里

101
01:35:52,550 --> 01:35:57,440
这里有一个IReserveSeats
是Train Train系统的入口

102
01:36:00,770 --> 01:36:07,340
这里有一个HTTP适配器,  适配器会有一个回调
我必须调用一个接口, 也是一个端口

103
01:36:07,340 --> 01:36:14,930
我有一个座位号
跟它说请给我预定一下

104
01:36:14,930 --> 01:36:19,190
然后我拿到一个reservation
适配器会做reservation和json之间的转换

105
01:36:23,810 --> 01:36:29,840
因为这里处理的是json, 而且是一个rest适配器,
所以是最合适的位置做这件事

106
01:36:29,840 --> 01:36:35,090
当我的业务逻辑需要一些额外的数据, 开始的时候没有提供给我的东西

107
01:36:35,090 --> 01:36:41,270
有许多种实现的方法
但假如说我需要访问外部的SSL依赖

108
01:36:41,270 --> 01:36:47,390
就是我们刚才提到的需要访问的外部三个web api

109
01:36:47,390 --> 01:36:52,160
我们需要在外部添加一些东西
为了实现这个我们需要访问内部的端口

110
01:36:54,940 --> 01:37:00,680
包括IBookSeats
 IProvideTrainTopology

111
01:37:00,680 --> 01:37:05,840
以及IGetBookingRef接口

112
01:37:05,840 --> 01:37:09,270
这些都是领域接口
端口还是属于领域内的

113
01:37:09,270 --> 01:37:14,010
这也是为什么棒棒糖这里是蓝色的

114
01:37:14,010 --> 01:37:17,970
但是适配器是属于基础架构的

115
01:37:17,970 --> 01:37:22,170
所以可以说适配器就是用来做基础设施代码和领域模型之间的映射的

116
01:37:22,170 --> 01:37:28,620
我解释清楚了吗

117
01:37:28,620 --> 01:37:36,060
好, 我们一会儿会在代码里再看到
所以端口和适配器就是控制进出, 很简单对吧

118
01:37:36,060 --> 01:37:40,650
好
但是当我们最初尝试实现它的时候产生了无数的问题

119
01:37:45,540 --> 01:37:50,880
有许多实现的方法. 我们会展示其中一个
我们需要初始化

120
01:37:50,880 --> 01:37:59,520
你需要自己创建这个东西
我之前用一个比喻

121
01:37:59,520 --> 01:38:02,670
叫做key ring解释给我的伙伴
现在也用它给你们解释一下

122
01:38:02,670 --> 01:38:07,710
首先第一步
我们这里将要讨论的是utopian应用的构成

123
01:38:07,710 --> 01:38:11,700
在你的应用里构造所有的依赖

124
01:38:11,700 --> 01:38:17,070
voila, 应用到系统里一切就工作了

125
01:38:17,070 --> 01:38:22,320
所以我们将要讨论的是如何建立起你的应用

126
01:38:22,320 --> 01:38:27,000
所以一共有三步
第一步是创建"I need to go out"适配器

127
01:38:27,000 --> 01:38:32,760
所有的适配器将会向后台的SSL要一个"please give me a topology"

128
01:38:32,760 --> 01:38:36,360
所以这里我们有两个适配器, Train Data Service Adapter
和Booking Reference Service Adapter

129
01:38:38,340 --> 01:38:44,460
它们就像向外面请求信息的钥匙
所以第一步就是获得这些钥匙

130
01:38:44,460 --> 01:38:49,980
第二步是我已经获得了这些钥匙, 我要把他们封装到领域内部

131
01:38:52,200 --> 01:38:57,330
六边形就是对应领域模型
这是一个web ticket manager

132
01:38:57,330 --> 01:39:01,440
所以web ticket manager会通过ports和外部世界交互

133
01:39:01,440 --> 01:39:09,930
然后我们会用新的将会和我们系统交互的适配器

134
01:39:09,930 --> 01:39:14,400
封装六边形

135
01:39:17,250 --> 01:39:22,890
我需要访问适配器
这是和我们应用通信的方法

136
01:39:22,890 --> 01:39:27,660
在我们做完这些之后
从应用的角度 从Asp.NET web api的角度

137
01:39:29,570 --> 01:39:35,070
我需要拥有的就只有入口适配器

138
01:39:35,070 --> 01:39:39,540
所以六边形和其他的适配器

139
01:39:39,540 --> 01:39:46,590
都是实现细节
在我们实现完以后

140
01:39:46,590 --> 01:39:51,660
对于Web api来说需要知道的就只有这个适配器

141
01:39:51,660 --> 01:39:58,110
也就是我们系统的入口

142
01:39:58,110 --> 01:40:04,199
好的 从另一个角度来看
 从图中看一下这三个步骤

143
01:40:04,199 --> 01:40:07,980
第一步我们创建了我们"I need to go out"适配器, 对应三个后台
然后我们将它们和这个六边形

144
01:40:07,980 --> 01:40:13,440
也就是和领域模型封装起来
就像俄罗斯套娃一样

145
01:40:13,440 --> 01:40:18,000
我需要出去 然后是六边形
然后我需要进去

146
01:40:18,000 --> 01:40:21,660
最后你就只需要进去的接口

147
01:40:21,660 --> 01:40:26,270
也就是对应用来说
唯一和系统进行交互的接口

148
01:40:26,270 --> 01:40:30,960
所以所有你需要知道的就只有这个适配器
注入到你的回调里

149
01:40:30,960 --> 01:40:38,489
像是controller等等的地方
有问题吗

150
01:40:41,400 --> 01:40:51,440
我们要写代码了 希望你们会有一些问题
所以我们来看看新版本的代码

151
01:40:51,440 --> 01:41:00,080
你可以注意到我们有了Reservation
这里的改动是调用了confirm方法

152
01:41:00,080 --> 01:41:09,410
因为这一行后面我可以确定没有exception
所以我就可以返回reservation

153
01:41:09,410 --> 01:41:16,230
对于测试的改动是这里
对

154
01:41:16,230 --> 01:41:23,429
我们返回一个reservation 我已经创建了一个适配器的开头
 这是一个output适配器

155
01:41:23,429 --> 01:41:31,380
包含一个AdaptReservation方法
这个方法几分钟后会被Thomas调用

156
01:41:31,380 --> 01:41:35,199
所以你已经开始将json的技术实现移到合适的地方
没错 好的

157
01:41:38,469 --> 01:41:44,499
那我觉得我可以先完成第一个单元测试

158
01:41:44,499 --> 01:41:53,229
我需要来实现我的构建过程
好的, 第一步就是

159
01:41:53,229 --> 01:41:58,539
创建"I want to go out"适配器 
比如这里 trainDataService 我们甚至可以重命名为trainDataServicesAdapter

160
01:42:00,820 --> 01:42:05,949
这是个糟糕的名字 它实际不是一个service
它在那里

161
01:42:05,949 --> 01:42:14,439
它也是一个代理
对于bookingReferenceServiceAdapter也是一样的

162
01:42:14,439 --> 01:42:17,349
好的 第一步我建立了对外界的依赖

163
01:42:17,349 --> 01:42:24,489
好的, 我现在需要的是创建六边形
实际上这里的六边形就是web ticket manager

164
01:42:27,189 --> 01:42:35,260
所以我们这里暂时叫做hexagon

165
01:42:35,260 --> 01:42:41,039
现实中你会用一个有业务含义的名字
所以不要告诉Eric我们这样做

166
01:42:45,280 --> 01:42:48,999
我这样做是因为我们现在在讲六边形和基础设施之间的关系

167
01:42:48,999 --> 01:42:53,349
所以我这里暂时命名为hexagon

168
01:42:53,349 --> 01:42:58,719
那么hexagon是不应该被直接调用的

169
01:42:58,719 --> 01:43:01,599
我之前说过应用会通过adapter和业务逻辑交互

170
01:43:01,599 --> 01:43:06,939
所以让我们来定义它 是的
第三步创建"I want to go in"适配器

171
01:43:06,939 --> 01:43:13,269
这里 我们应该起什么名字

172
01:43:13,269 --> 01:43:20,409
哦 这里 你已经定义好了 应该是一样的名字
所以我会创建它 提供我需要提供的 hexagon

173
01:43:25,059 --> 01:43:30,159
是的 就像俄罗斯套娃 所以这两个的适配器用来创建hexagon
然后hexagon用来生成这个对象 

174
01:43:32,829 --> 01:43:39,189
好的 我创建了一个构造函数 因为到现在为止你只定义了一个static方法

175
01:43:39,189 --> 01:43:44,709
好的 你可能需要做一下抽象
不应该注入webTicketManager

176
01:43:48,969 --> 01:43:53,590
是的 事实上你是对的, 我们谈到过端口
端口就像接口

177
01:43:53,590 --> 01:44:00,429
所以我可以做的 是对webTicketManager
提出一个接口

178
01:44:00,429 --> 01:44:06,670
这个名字不够好 我们后面会改
所以让我们提出一个接口

179
01:44:06,670 --> 01:44:20,170
就叫做IReserveSeats 像这样
对不起 我之前工作在mac上

180
01:44:20,170 --> 01:44:25,300
所以我们试着选一个合适的键盘
IReserveSeats

181
01:44:25,300 --> 01:44:33,039
你每天都工作在pc上啊
是的 我在试着找个借口啊

182
01:44:33,039 --> 01:44:44,729
现场压力 是的
 所以我在这个接口中添加了reserve方法

183
01:44:44,729 --> 01:44:49,929
这里 这是一个端口
用来访问领域模型

184
01:44:49,929 --> 01:44:56,559
那么回到代码中 我给这个适配器传入的
是hexagon

185
01:44:56,559 --> 01:45:04,150
 oops 跳转到它的实现
应该是IReserveSeat

186
01:45:07,860 --> 01:45:16,150
好 我还是将它设为私有属性
这里我将需要它

187
01:45:16,150 --> 01:45:22,689
所以我定义好了reservation adapter
 okay 第三步是创建reservation adapter

188
01:45:22,689 --> 01:45:29,469
让我们把它抽成 reservationAdaper okay
我的想法将对hexagon直接的调用

189
01:45:29,469 --> 01:45:34,959
替换成通过适配器的调用

190
01:45:34,959 --> 01:45:40,539
所以为了让它编译通过
先到web controller里

191
01:45:40,539 --> 01:45:46,479
这是要调用适配器的地方

192
01:45:46,479 --> 01:45:53,079
所以在controller中 首先将是获得reservation request dto
所以会有一个reservation request dto

193
01:45:54,909 --> 01:45:59,710
我会将reservation dto传到适配器
它将会返回一个reservation的json 对吧

194
01:45:59,710 --> 01:46:06,590
那么我觉得reservation dto不在合适的地方

195
01:46:06,590 --> 01:46:11,420
在测试中无法访问到它

196
01:46:11,420 --> 01:46:16,580
所以我建议我们移动一下它的位置

197
01:46:16,580 --> 01:46:21,830
创建新的工程比较痛苦 时间较长
所以我就只创建一个文件夹

198
01:46:21,830 --> 01:46:25,850
我会创建一个Train Train下面的domain和infra文件夹

199
01:46:25,850 --> 01:46:33,620
所以我们可以合理地分离出各种类型
隔离出基础设施
所以我们将其放到合适的位置

200
01:46:36,590 --> 01:46:43,190
选择move type into matching files
来确保每个类型都是对应的文件

201
01:46:45,860 --> 01:46:53,090
BookingReferenceService 我应该放到哪儿
domain还是infra

202
01:46:53,090 --> 01:47:02,200
这个名字不好 正常情况下它肯定会有更好的名字
是的 应该放到infra里
yeah coach

203
01:47:02,200 --> 01:47:11,600
coach类 放到domain 对 IBookingReferenceService 
它是一个接口 所以它是一个端口

204
01:47:11,600 --> 01:47:20,570
所以应该是放到domain里 IReservedSeats
端口 所以是domain 没错

205
01:47:21,950 --> 01:47:29,090
ITrainDataservice
它应该在domain下面 它是一个接口

206
01:47:29,090 --> 01:47:35,860
yeah reservation 应该是domain
reservationAttempt 一样
reservationAttemptFailure 也是一样

207
01:47:39,640 --> 01:47:43,820
reservationFailure 也是一个domain

208
01:47:45,290 --> 01:47:49,340
实际上给它一个更合适的名字它会有更多的价值

209
01:47:49,340 --> 01:47:55,430
seats? domain. 我很开心
我们的domain相比infrastructure更多

210
01:47:55,430 --> 01:48:02,740
到目前为止我的项目都不是这样的
那么SeatJsonPoco, infra

211
01:48:03,370 --> 01:48:10,280
SeatsReservationAdapter? adapter肯定是infrastructure下面的

212
01:48:10,280 --> 01:48:15,060
ThreadsholdTrainCapacity? domain, 绝对是

213
01:48:15,060 --> 01:48:24,030
即使我们起不出更好的名字 Train? domain
我们还剩什么TimeDataSservice, infrastructure 它是适配器

214
01:48:28,620 --> 01:48:36,450
那么WebTicketManager, domain. 它是hexagon

215
01:48:36,450 --> 01:48:45,480
不过到现在为止它还有两个http服务相关的依赖

216
01:48:45,480 --> 01:48:48,230
我们暂时还是把它放在这里

217
01:48:49,370 --> 01:48:54,390
在我们把这里打扫干净之前还是把它放在根目录

218
01:48:54,390 --> 01:48:57,930
修改一下命名空间
是的 应该修改一下项目的命名空间

219
01:48:57,930 --> 01:49:03,060
那么所有的文件应该都放在了正确的地方

220
01:49:03,060 --> 01:49:16,080
我刚才说到了
我应该找到测试 TrainTrainShould 让我们回到测试

221
01:49:19,080 --> 01:49:22,620
好的 我刚才提到我希望引入和ReservationAdapter交互的途径

222
01:49:22,620 --> 01:49:28,680
让我们先称之为Post dto
应该可以找到更好的名字 但是

223
01:49:28,680 --> 01:49:34,440
这里应该是new reservation request
我不确定你是否移动过它

224
01:49:36,630 --> 01:49:43,530
我不确定 我应该没有移
哦对 ReservationRequestDto

225
01:49:43,530 --> 01:49:54,390
它在错误的项目里 我需要把它移过来
移到TrainTrain下的infra文件夹里

226
01:49:54,390 --> 01:50:00,360
所以现在我可以在测试中引用它了
否则它是web api的一部分的话就没办法引用到

227
01:50:03,630 --> 01:50:10,290
好的 所以现在我会创建一个新的reservation request dto
因为这是ASP.net的项目

228
01:50:10,290 --> 01:50:16,290
通常它会帮我初始化
但是这里number_of_seats

229
01:50:16,290 --> 01:50:23,530
对应的是seatsRequestedCount
另外一个是train_id

230
01:50:23,530 --> 01:50:29,890
设置成和我们接受的输入json相等的

231
01:50:29,890 --> 01:50:33,520
它是一个poco 也就是TrainId

232
01:50:33,520 --> 01:50:42,570
对应我们的train
所以这里我post一个新的请求dto

233
01:50:46,900 --> 01:50:56,020
我们也许可以抽一个变量 看起来更整洁
所以我们现在有了reservationRequestDto 

234
01:50:56,020 --> 01:51:01,240
然后我用适配器post这个reservation的请求
我想进入适配器 创建这个方法 好的

235
01:51:03,550 --> 01:51:11,200
我将返回json string而不是void

236
01:51:11,200 --> 01:51:17,710
这里我可以返回asp.net内部的类作为response

237
01:51:17,710 --> 01:51:21,940
但今天我不会具体做了

238
01:51:21,940 --> 01:51:29,640
所以这里是reservation dto
所以这里的post方法

239
01:51:29,640 --> 01:51:36,390
应该返回给我一个
jsonReservation

240
01:51:36,390 --> 01:51:40,390
为什么不呢
所以适配器会给我返回这个

241
01:51:40,390 --> 01:51:46,260
我将对它进行断言
所以删掉整个

242
01:51:46,410 --> 01:51:51,940
然后jsonReservation就应该和这个json相等
对 期待的结果

243
01:51:51,940 --> 01:51:56,740
它还是对的 因为我还没有引入适配器

244
01:51:56,740 --> 01:52:03,160
适配器一共有三步来创建整个六边形架构

245
01:52:03,160 --> 01:52:09,480
我的意思是每个适配器的方法基本上都需要三个步骤

246
01:52:09,480 --> 01:52:13,440
第一步是讲基础设施代码转化为领域模型

247
01:52:13,440 --> 01:52:18,190
第二步是调用业务逻辑代码

248
01:52:18,190 --> 01:52:23,800
然后第三步是将领域代码的结果在转化为基础架构代码

249
01:52:23,800 --> 01:52:29,860
这就是每个方法实现的思路
所以让我们实现它 在这种情况下我不需要适配

250
01:52:31,540 --> 01:52:34,679
所以这里我为number_of_seats引入一个新的变量

251
01:52:34,679 --> 01:52:40,800
reservationRequestDto

252
01:52:40,800 --> 01:52:47,640
在现实中你可能需要自己来实现序列化的技术

253
01:52:47,640 --> 01:52:53,040
因为asp.net帮我为我们做了
但有时你需要用本地变量翻译json

254
01:52:53,040 --> 01:52:59,820
并转化成领域模型
我刚才做的就是定义了一些变量

255
01:52:59,820 --> 01:53:04,500
但这里时机就是你将要翻译 转换 调整的地方

256
01:53:04,500 --> 01:53:10,110
以此达到能够调用到业务逻辑的目的
好的 现在我用hexagon.Reserve()

257
01:53:10,110 --> 01:53:16,679
它是一个业务领域方法

258
01:53:16,679 --> 01:53:23,640
我已经定义了本地变量trainId numberOfSeats
让我把它改成numberOfSeatsRequested

259
01:53:23,640 --> 01:53:36,900
好的 我调用了hexagon的方法
它返回给我一个reservation

260
01:53:37,830 --> 01:53:43,710
因为它是一个async方法因此我需要在这里await

261
01:53:43,710 --> 01:53:49,500
对 这是c#用来实现异步的方法

262
01:53:49,500 --> 01:53:54,840
因为reserve方法也调用了其他的async方法
所以我也必须这样做

263
01:53:54,840 --> 01:54:01,020
接下来是讲领域模型映射回基础设施
这个方法Bruno已经实现了

264
01:54:01,020 --> 01:54:05,300
adapterReservation 参数是reservation的string

265
01:54:05,300 --> 01:54:12,090
对 直接返回
所以大家可以看到我从业务代码中得到一个reservation

266
01:54:12,090 --> 01:54:22,230
然后我做的事就是将其适配到json
这是还是红的 我错在哪儿了

267
01:54:26,610 --> 01:54:29,689
这里

268
01:54:32,430 --> 01:54:44,650
这里你也需要await
对不起 现在编译通过 是async/await的问题

269
01:54:47,020 --> 01:54:52,780
这是第一次用asp.net实现
所以可以在第一个验收测试里看到

270
01:54:54,460 --> 01:54:59,530
创建应用所需要做的
我不知道你们觉得接下来做什么比较好

271
01:54:59,530 --> 01:55:08,650
我们只剩不到10分钟了
这一部分其实应该放到application的启动阶段

272
01:55:08,650 --> 01:55:13,000
我可以接着做这个
把它插入到web ticket manager

273
01:55:13,000 --> 01:55:18,370
也许留一些问答的时间更好
或者用来总结一下

274
01:55:18,370 --> 01:55:21,969
你们觉得呢
我需要加速了

275
01:55:21,969 --> 01:55:35,320
因为时间有一点不够了
总结一下 我们从一个场景开始

276
01:55:35,320 --> 01:55:42,130
我们有一个web ticket manager
其中有非常多过程式的代码

277
01:55:42,130 --> 01:55:48,450
然后我们把它重构得风格更一致

278
01:55:48,450 --> 01:55:56,370
我不知道怎么说
更短更整洁的代码

279
01:55:56,370 --> 01:56:02,800
重构后的Reserve方法是这样的
这就是我们主要做的事

280
01:56:02,800 --> 01:56:09,489
最重要的是我们在代码中尽可能使用了领域语言
它之前是遗留代码 非常糟糕

281
01:56:12,430 --> 01:56:17,469
如果我们有时间运行一下

282
01:56:17,469 --> 01:56:25,050
警告会得更少

283
01:56:25,050 --> 01:56:30,160
我们的代码基本上是围绕reservation train 

284
01:56:30,160 --> 01:56:35,710
reservationAttempt isFulfilled

285
01:56:35,710 --> 01:56:42,469
你看即使我们的领域专家读不懂我们的代码
我们也可以边看代码边解释给他

286
01:56:42,469 --> 01:56:49,070
可以进行讨论
然后他就可以说 不对

287
01:56:49,070 --> 01:56:54,340
这不是我想要的

288
01:56:54,340 --> 01:57:00,199
所以这样可以减少我们的实现和讨论之间的摩擦, 减小分歧
尊重他的意见会更好

289
01:57:04,360 --> 01:57:11,810
是的 我们有一个叫ndepend的工具
马上会给你们展示

290
01:57:11,810 --> 01:57:19,310
但是切换屏幕比较花时间
我们先做一个最后的总结

291
01:57:19,310 --> 01:57:23,810
今天我们没有时间让你体验
因为我们的领域专家在巴黎

292
01:57:23,810 --> 01:57:29,120
我们和他设计的第一版系统已经在stage了
和你们的领域专家讨论是非常关键的

293
01:57:31,429 --> 01:57:36,710
大部分出问题的项目都是因为
程序员甚至不被允许和领域专家讨论

294
01:57:36,710 --> 01:57:41,239
对我来说, 如果是这样我肯定不会去这个项目. 但在我的职业生涯的开端

295
01:57:43,370 --> 01:57:50,300
并不是这样. 它需要勇气时间和决心来执行它.

296
01:57:50,300 --> 01:57:58,120
但它非常关键
下一点是不要被遗留代码吓退

297
01:57:58,120 --> 01:58:04,610
因为我是一个教练
我学习如何重构代码

298
01:58:04,610 --> 01:58:09,560
一般代码有一些依赖的时候会说
我的这个代码是不可测的

299
01:58:09,560 --> 01:58:16,820
我们可以测试任何的代码
所以不要被吓到
你要这么做是需要勇气的

300
01:58:21,530 --> 01:58:27,080
是的 它会花很多时间 但是可以实现的

301
01:58:27,080 --> 01:58:30,260
今天我们没有用很多的手法
主要用到的是Martin Fowler的重构一书里的两个方法

302
01:58:30,260 --> 01:58:35,780
它们是提取和移动方法
非常简单 首先第一步是要有测试覆盖

303
01:58:38,199 --> 01:58:44,739
然后就可以非常容易的提取和移动
更复杂的是找到更合适的命名

304
01:58:44,739 --> 01:58:53,640
在领域设计上投资
我们的代码在你们的建议下有了很大改进

305
01:58:53,640 --> 01:58:57,930
非常的生动有趣

306
01:58:57,930 --> 01:59:05,730
你们非常积极的和我们互动 非常感谢

307
01:59:07,190 --> 01:59:12,340
[鼓掌]
