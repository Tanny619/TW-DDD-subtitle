1
00:30:26,000 --> 00:30:28,304
好，还有什么你想改进的吗？

2
00:30:29,072 --> 00:30:29,584
是的

3
00:30:30,096 --> 00:30:31,888
你看出来还有不爽的地方吗？

4
00:30:32,656 --> 00:30:35,728
是的。这里全是过程代码，一个方法，一屏幕高

5
00:30:36,240 --> 00:30:39,824
做这个，做那个，做这个等等

6
00:30:40,592 --> 00:30:41,616
就是一些脚本

7
00:30:45,968 --> 00:30:50,832
是的。这里"get the train"就没有用了

8
00:30:51,088 --> 00:30:52,624
所以，我们删掉它

9
00:30:53,136 --> 00:30:54,160
好，现在好多了

10
00:30:54,416 --> 00:30:57,488
现在，我们的问题是，

11
00:30:58,256 --> 00:31:04,400
我们共享了"train"，通常这是要返回领域对象，而不是JSON数据

12
00:31:05,936 --> 00:31:07,984
我们看到我们这里有个物理代理

13
00:31:09,264 --> 00:31:15,408
来扩展WebAPI，来组成一个

14
00:31:15,664 --> 00:31:20,784
适配器，通过适配器模式

15
00:31:21,296 --> 00:31:27,440
我们还会继续来着这段代码，所以不用担心你不知道。对比返回

16
00:31:27,696 --> 00:31:30,512
JSON字符串。

17
00:31:30,768 --> 00:31:32,560
我们让它返回Train对象。好的。

18
00:31:33,072 --> 00:31:39,216
这样我们就可以在函数内处理JSON了

19
00:31:39,728 --> 00:31:44,592
这样可以更面向领域，不会和技术细节

20
00:31:44,848 --> 00:31:46,896
纠缠在一起。你觉着呢？同意。你觉着还好？

21
00:31:50,992 --> 00:31:53,040
所以，我发现这个文件

22
00:31:53,296 --> 00:31:55,344
有一个Train的构造函数

23
00:31:55,600 --> 00:32:01,744
Train。好的。我们看到很多反序列化JSON的东西。

24
00:32:02,768 --> 00:32:05,328
这个文件就是这样

25
00:32:05,584 --> 00:32:09,936
这个不要选中吗？

26
00:32:16,080 --> 00:32:17,872
删掉。好的。

27
00:32:19,152 --> 00:32:22,480
这个也没有用到

28
00:32:24,016 --> 00:32:24,528
我们也删除它

29
00:32:25,040 --> 00:32:25,808


30
00:32:26,064 --> 00:32:29,648
这个也变灰了

31
00:32:31,952 --> 00:32:35,280
或者你可以把它分拆到几个文件中.. 嗯，删掉它。

32
00:32:37,584 --> 00:32:38,864
现在，我们在

33
00:32:39,888 --> 00:32:40,656
Train

34
00:32:40,912 --> 00:32:41,680
这个类中

35
00:32:42,192 --> 00:32:47,312
是的。Train没有太多的行为，除了

36
00:32:47,568 --> 00:32:49,872
解析

37
00:32:50,128 --> 00:32:53,200
JSON

38
00:32:53,712 --> 00:32:55,248
神奇的Resharper

39
00:32:55,760 --> 00:32:56,272
好

40
00:32:57,296 --> 00:32:59,856
我们使用Lambda。好的。好。

41
00:33:00,112 --> 00:33:06,256
我要移动这个了。这里有很多..属性...字段...好。

42
00:33:06,512 --> 00:33:12,400
我们有一个构造函数。全是技术细节了。

43
00:33:13,680 --> 00:33:14,704


44
00:33:14,960 --> 00:33:15,984
你还有什么建议吗？

45
00:33:20,592 --> 00:33:21,616
如果我来喝点水

46
00:33:22,128 --> 00:33:23,152
[观众问题]

47
00:33:30,320 --> 00:33:35,696
这里有个更好的地方来解析JSON

48
00:33:35,952 --> 00:33:38,512
Train是领域模型的一部分，所以，我们不应该在这里做这件事。

49
00:33:39,024 --> 00:33:45,168
好吧，让我们来修改。好，我来创建

50
00:33:46,960 --> 00:33:49,264
一个小[方法]来封装我要移动的代码

51
00:33:49,776 --> 00:33:55,920
我们会做很多次的这种操作。抽取，移动。抽取函数，移动到合适的位置。

52
00:33:56,176 --> 00:34:00,784
我们会在会议中多次使用到。好吧，让我们来做第一次。

53
00:34:01,040 --> 00:34:03,088
我想选中我要的所有代码

54
00:34:03,600 --> 00:34:04,624
来抽取，移动

55
00:34:05,392 --> 00:34:06,416
这个可以吗？

56
00:34:06,928 --> 00:34:08,208


57
00:34:09,232 --> 00:34:10,256


58
00:34:10,512 --> 00:34:11,024


59
00:34:11,536 --> 00:34:13,328
再多一点？好的，这个，好的。

60
00:34:14,352 --> 00:34:17,168
代码太长了

61
00:34:20,496 --> 00:34:25,616
好的，我们抽取了函数，但是它现在依然是实体函数。好的。

62
00:34:25,872 --> 00:34:27,408
这个是

63
00:34:27,664 --> 00:34:28,688
Train topology

64
00:34:28,944 --> 00:34:31,248
因为在解析JSON

65
00:34:31,504 --> 00:34:32,016
所以，

66
00:34:32,528 --> 00:34:35,344
对Train的很多属性做了赋值

67
00:34:36,112 --> 00:34:37,904
不错的方法

68
00:34:38,160 --> 00:34:38,672
这个吗？

69
00:34:39,696 --> 00:34:42,256
所以，抽取函数的人

70
00:34:42,768 --> 00:34:43,792
可以把它

71
00:34:44,304 --> 00:34:48,144
移动到新的位置

72
00:34:48,656 --> 00:34:52,496
一个好的查看依赖的方法。因为我想移动它

73
00:34:53,008 --> 00:34:56,080
但是我不想增加依赖

74
00:34:56,336 --> 00:34:58,128
我知道我想隔离

75
00:34:58,384 --> 00:34:58,896
所以

76
00:34:59,152 --> 00:35:00,176
我使用了静态函数

77
00:35:02,992 --> 00:35:04,528
现在出现了几个下划线

78
00:35:05,040 --> 00:35:05,552
几个下划线

79
00:35:05,808 --> 00:35:07,344
这里，这里，因为它们是静态的

80
00:35:07,856 --> 00:35:14,000
现在我们要修改第二个测试，来看看，是否静态... 出现了错误

81
00:35:14,256 --> 00:35:17,584
好的，来看看如何切断这些

82
00:35:17,840 --> 00:35:19,120
好的，联系。

83
00:35:28,790 --> 00:35:38,000
是的，实际上...

84
00:35:38,000 --> 00:35:43,460
[观众问题]

85
00:35:43,460 --> 00:35:49,190
这是一个好主意。我们可以做的更多。如果string不是空，我会增加

86
00:35:49,190 --> 00:35:54,619
reserve seat，而不是现在就改变seat的值

87
00:35:54,619 --> 00:35:59,359
我们或许能够减掉这个行为
每次

88
00:35:59,359 --> 00:36:04,640
调用属性的方法
测试或许是一种方法

89
00:36:04,640 --> 00:36:11,440
你认为呢？让我们来试试吧
我们在这里赋值，而不是让方法改变值

90
00:36:11,440 --> 00:36:19,850
需要一些东西，类似 'seat' ..

91
00:36:19,850 --> 00:36:24,640
哪里？count这里

92
00:36:24,640 --> 00:36:31,150
额，不是~ 像这样一样

93
00:36:31,150 --> 00:36:38,530
Richard你认为你知道Java stream吗？

94
00:36:38,530 --> 00:36:44,940
这种方式更函数式的处理集合和枚举

95
00:36:44,940 --> 00:36:49,780
如果不这样写。下面，我这样来写，取得seat的列表，计算每一个seat

96
00:36:49,780 --> 00:36:54,910
这里lambda是说，每个没有被预定的座位

97
00:36:57,790 --> 00:37:03,610
好的。我很惊讶。
所以你可以处理这些了

98
00:37:03,610 --> 00:37:11,140
它可以在另一个层面完成。或许我可以做类似的关联。

99
00:37:13,840 --> 00:37:18,970
是的。演示一下。

100
00:37:21,040 --> 00:37:32,280
它或许是一个静态函数。我改变了函数签名。

101
00:37:32,280 --> 00:37:41,410
像一组座位。
好的。
然后我改变局部变量，现在我返回seat

102
00:37:47,880 --> 00:37:54,010
所以我们可以抽取函数，所以当需要的时候直接调用

103
00:37:54,010 --> 00:38:00,250
所以，我们适配train topology
这是第一步

104
00:38:00,250 --> 00:38:05,140
因为我们要移动到一个合适的位置

105
00:38:05,140 --> 00:38:12,970
因为。。实际上。。
时间关系

106
00:38:12,970 --> 00:38:19,570
好的。所以，抽取函数，移动到合适的位置

107
00:38:19,570 --> 00:38:27,070
所以，我们可以容易的移动它。
让我们把它放到。。
如果你回到被调用的方法

108
00:38:27,070 --> 00:38:31,859
这里，我们得到一个train

109
00:38:37,150 --> 00:38:42,430
好的。
这里很有趣。
没有使用JSON topology来或得一个train

110
00:38:44,500 --> 00:38:49,799
或许你可以把静态函数放到train data service中

111
00:38:49,799 --> 00:39:03,690
好的，让我们移动它。放到data service中，好吗？

112
00:39:04,270 --> 00:39:08,710
目前为止，我们完成了不错的工作
train中还有依赖，我们一会儿再来改动

113
00:39:08,710 --> 00:39:16,260
所以，我们使它public
是的，并且

114
00:39:16,260 --> 00:39:22,089
目标是改变这个
get train 函数
我来改变函数签名而不是返回task的字符串

115
00:39:25,270 --> 00:39:30,339
好的，修改它。我认为这里请求web api

116
00:39:30,339 --> 00:39:38,020
它有点复杂。但是。。好的。。
你要读懂它，它返回了一个train。

117
00:39:38,020 --> 00:39:42,880
是的。从业务角度，这样更好

118
00:39:42,880 --> 00:39:49,630
我将取得train
好的
你有了新的train，来自topology

119
00:39:49,630 --> 00:39:57,970
但是，train没有使用topology。我们想适配json，所以我们调用它适配train topology

120
00:40:04,529 --> 00:40:12,789
但是，当前train没有接收
你必须要改变它
是的

121
00:40:12,789 --> 00:40:17,079
我必须修改它。
来接收一个seat列表
是的

122
00:40:17,079 --> 00:40:20,319
所以，为了初识化tain，我们会接收一组seat。这样更容易 讨论和接收

123
00:40:20,319 --> 00:40:25,750
是的。删掉它。

124
00:40:25,750 --> 00:40:30,609
所以，我们没有从train到train data service
的引用了

125
00:40:30,609 --> 00:40:38,770
所以它就是一个简单的gettrain了，返回一个train

126
00:40:38,770 --> 00:40:42,579
所以你也不再需要它了

127
00:40:42,579 --> 00:40:47,820
我可以删掉它了
这里我们有一些。。。
好的，是，这样子好多了

128
00:40:47,820 --> 00:40:49,620
我们向train data service请求一个train，我们就获得了一个train

129
00:40:51,240 --> 00:40:55,530
我来编译一下，因为我或许会破坏已有功能。
嗯，这样好多了

130
00:40:55,530 --> 00:41:00,420
还有一些困扰我的
即使它没有编译，也是绿的

131
00:41:00,420 --> 00:41:07,370
是的，我觉着这是一个bug。是的，像是一个bug

132
00:41:07,370 --> 00:41:11,970
我们对train做了个足够多的测试

133
00:41:11,970 --> 00:41:17,220
对于给定的json，给定的topology
这里我们必须做相同的事情

134
00:41:17,220 --> 00:41:24,210
我们不得不调整以前的代码，我们期望。。

135
00:41:24,210 --> 00:41:32,370
签名到新的函数
好的，编译，好了

136
00:41:32,370 --> 00:41:35,130
好的，
不错

137
00:41:35,130 --> 00:41:39,600
你回来了...
让我们返回...
谢谢你，Bruno

138
00:41:39,600 --> 00:41:45,050
好的。
我们实际上移动了train的一部分的topology的代码

139
00:41:45,050 --> 00:41:50,030


140
00:41:50,030 --> 00:41:55,430
现在好多了，这段代码看起来舒服多了。但是还是有很多的问题

141
00:41:57,290 --> 00:42:03,800
例如，我们来看看train。
好的。我们做了一些清洁，改变了一些。

142
00:42:03,800 --> 00:42:13,880
但是，这个train是一个纯的数据类，没有任何责任

143
00:42:13,880 --> 00:42:18,650
我不确定，曾经有个朋友说过，

144
00:42:18,650 --> 00:42:23,180
这是对象是年轻人对象，无论如何也要承担一些责任

145
00:42:25,970 --> 00:42:33,650
是的。让我们来吧

146
00:42:33,650 --> 00:42:39,710
我们有seat的概念。

147
00:42:39,710 --> 00:42:45,860
这是一个领域名字，

148
00:42:45,860 --> 00:42:57,620
你知道我们的领域的应该包含什么

149
00:42:59,360 --> 00:43:03,950
所以，我们在代码里缺少所有的领域概念

150
00:43:06,800 --> 00:43:12,470
但是，我们有数据类

151
00:43:18,200 --> 00:43:22,010
和一堆行为，我建议来包装这些行为

152
00:43:22,010 --> 00:43:29,300
把他们放到合适的位置，打破这些年轻对象

153
00:43:29,300 --> 00:43:37,310
或许可以参考幻灯片，让我们一起直观的看看
我们有A，B类

154
00:43:40,970 --> 00:43:44,990
A对应web ticket manager类，B是train

155
00:43:44,990 --> 00:43:50,300
所以，看看我们要做什么。我们抽取行为

156
00:43:50,300 --> 00:43:54,200
移动到相同的类里，

157
00:43:56,870 --> 00:44:01,310
然后在移动到合适的位置
比如train，在今天结束时，

158
00:44:01,310 --> 00:44:06,560
我们要做的更多。
很好的平衡

159
00:44:06,560 --> 00:44:14,030
是的。领域的很多东西
是的
让我们返回代码

160
00:44:14,030 --> 00:44:22,970
所以，我建议来做一下
好的。每个火车保留作为是第一业务规则。

161
00:44:25,490 --> 00:44:30,370
火车不应该超过它的最大承载能力。我建议抽取一个方法

162
00:44:30,370 --> 00:44:41,600
但是，或许。
它没有超过火车的总能力

163
00:44:41,600 --> 00:44:45,260
一旦。。。这里。。。

164
00:44:45,260 --> 00:44:53,450
是的。capacity
抱歉，我抽取了一个非静态方法。
可以方便的移动

165
00:44:57,380 --> 00:45:07,580
这个方法。。我们应该根据。。移动它。
train

166
00:45:07,580 --> 00:45:13,730
是的。这里有个提示。Resharper的F6可以移动

167
00:45:13,730 --> 00:45:18,680
你可以传递train而不是参数，这样你就方便的移动到了train中

168
00:45:18,680 --> 00:45:23,780
好的。我们有了train。当我请求座位的时候，不会超过承载能力

169
00:45:23,780 --> 00:45:33,950
好的。这里我们可以建设一个可用seat列表

170
00:45:36,770 --> 00:45:43,280
所以我们可以找到可用的seat

171
00:46:02,260 --> 00:46:06,569
实际上，我们这里可以介绍一些概念。
你认为呢？

172
00:46:08,790 --> 00:46:22,530
[观众问题]

173
00:46:23,119 --> 00:46:28,440
是的。今天结束的时候，我们需要所有的座位在同一节车厢中

174
00:46:28,440 --> 00:46:33,500
但是，在这之前领域专家说了很多reservation attempt

175
00:46:33,500 --> 00:46:40,050
这对他是一个很重要的概念。所以，我建议可以引入这个部分，来代替available seats

176
00:46:40,050 --> 00:46:43,950


177
00:46:50,690 --> 00:46:57,480
在我们改进代码之前，Rruno要show一些东西

178
00:46:57,480 --> 00:47:04,319
或许你们有的人已经知道了

179
00:47:04,319 --> 00:47:10,589
这是一个检查依赖的工具 JArchitect

180
00:47:10,589 --> 00:47:18,569
可以用在java或者c++，是一个很高级的工具。
它可以分析代码

181
00:47:18,569 --> 00:47:25,170
可以报warning或者error。我们一直和Macau深度合作

182
00:47:25,170 --> 00:47:31,170
是的，我们要求他介绍一个新的检查代码的方法

183
00:47:31,170 --> 00:47:35,010
使用统一语言, 现在还在原型阶段

184
00:47:35,010 --> 00:47:41,069
没有发布，我们想象你有一个团队。你有遗留代码，你有知道领域专家的词典

185
00:47:45,060 --> 00:47:50,520
并且创建了规则，它依赖统一语言调用你的代码

186
00:47:50,520 --> 00:47:56,700
你可以看到我们有一些问题

187
00:47:56,700 --> 00:48:03,240
这些单词没有很好的一致。

188
00:48:03,240 --> 00:48:10,530
我们创建了一组单词作为我们的领域

189
00:48:10,530 --> 00:48:16,920
像train等等，当前我们定义了你想要的每个领域

190
00:48:16,920 --> 00:48:23,430
我们要检查的工具，它仍然在alpha阶段

191
00:48:27,059 --> 00:48:32,729
但是我认为这会非常有趣，当它成熟后。能够有一些代码的味道检查

192
00:48:35,249 --> 00:48:43,949
好的，好的
 运行一下
结果如何？

193
00:48:43,949 --> 00:48:52,619
让我们回到业务。

194
00:48:52,619 --> 00:48:58,079
我们有一组 available seats，我建议我们改变签名

195
00:48:58,079 --> 00:49:02,699
我们引入reservation attempt的概念。所以不再返回一组seats，

196
00:49:02,699 --> 00:49:13,349
我们来返回reservation attempt，哦，写错了。

197
00:49:13,349 --> 00:49:15,949
谢谢你

198
00:49:16,730 --> 00:49:24,170
好的，类型不存在。是的，我知道我可能会重命名它

199
00:49:24,170 --> 00:49:37,730
抱歉

200
00:49:37,730 --> 00:49:41,240
reservation attempt不存在，让我们创建它。好吗？

201
00:49:43,670 --> 00:49:54,049
这里，这个函数返回reservation attempt

202
00:49:54,049 --> 00:49:59,079
我要做的就是在这里创建它，在最后

203
00:49:59,079 --> 00:50:05,510
返回一个reservation attempt,
好吗？
给它提供刚刚找到的一组seat

204
00:50:05,510 --> 00:50:11,270
我要做的就是创建一个构造函数，接受一组seat

205
00:50:14,569 --> 00:50:23,690
好的，这就是我想要的。
或许我需要遍历seats

206
00:50:23,690 --> 00:50:29,809
让我从创建一个seat属性[参数]开始

207
00:50:29,809 --> 00:50:36,410
或许创建一个只读属性，

208
00:50:39,170 --> 00:50:44,869
因为我需要遍历reservation attempt的seats
好吗？

209
00:50:44,869 --> 00:50:49,819
所以，我创建了一个 reservation attemp ，它有个 seats 的属性。就这样。

210
00:50:49,819 --> 00:50:55,730
很好。所以 findavailableseats 现在，名字
改为 build reservation temp 更好

211
00:50:55,730 --> 00:51:02,990
是的。
所以现在方法创建reservation attempt，根据找到的可用座位

212
00:51:05,150 --> 00:51:08,450
返回 reservation attemp
大家觉着如何？

213
00:51:12,410 --> 00:51:17,569
现在代码已经不能编译了，因为我一直使用seats列表

214
00:51:17,569 --> 00:51:23,210
现在已经变成了reservation attempt。

215
00:51:23,210 --> 00:51:28,820
然后加入到seats中，

216
00:51:28,820 --> 00:51:33,320
让我来填充这三个地方

217
00:51:33,320 --> 00:51:46,040
f12
oops 
得到 seats

218
00:51:46,040 --> 00:51:51,260
应该可以编译了，检查一下
是的，可以了，绿了

219
00:51:51,260 --> 00:51:58,910
所以，这里我直接创建了一个概念，它来自于领域专家 reservation attempt，来代替一组seats

220
00:52:02,300 --> 00:52:07,520
可以吗 ?
reservation attempt可以做什么呢？

221
00:52:07,520 --> 00:52:14,000
这里，

222
00:52:14,000 --> 00:52:18,770
像是说reservation attempt满了吗？

223
00:52:18,770 --> 00:52:24,560
领域专家谈论了很多，让我们来为它创建一个方法。抽取，移动

224
00:52:24,560 --> 00:52:31,640
满了还是没满

225
00:52:31,640 --> 00:52:37,040
我觉着不错了
所以我们来问reservation attempt你满了吗？

226
00:52:37,040 --> 00:52:44,510
所以，第一步抽取，先放在当前类中，然后移动

227
00:52:44,510 --> 00:52:47,530
抱歉

228
00:52:47,530 --> 00:52:51,590
我抽取了行为，然后把它放到合适位置，就是revervation attempt

229
00:52:51,590 --> 00:52:56,630
还有一些东西困扰我，你把seat request count传递了两次

230
00:52:56,630 --> 00:53:01,400
是的，这里传了，这里传了

231
00:53:01,400 --> 00:53:06,320
实际上你可以在构造reservation attempt的时候传递 seat request count，这样只需要一次

232
00:53:06,320 --> 00:53:10,250
我们就不需要每次检查是否满了的时候，都传递给它

233
00:53:10,250 --> 00:53:16,810
我同意，做吧
我们到实现

234
00:53:16,810 --> 00:53:21,110
我在reservation attempt 的构造函数中提供了seats request count

235
00:53:21,110 --> 00:53:31,000
好的，抱歉，
我好想犯了个错误

236
00:53:32,100 --> 00:53:38,970
好的。我改变了revervation attempt 的构造函数。我倾向于给构造函数加一个参数

237
00:53:38,970 --> 00:53:44,520
是的，让我们来做一下。
把 seats requested count 放到这里

238
00:53:44,520 --> 00:53:49,290
我简单创建一个只读的属性，它不是public的。

239
00:53:49,290 --> 00:53:53,580
所以，类外不能访问

240
00:53:53,580 --> 00:53:59,610
好的，我有它了。
怎么来使用呢

241
00:53:59,610 --> 00:54:06,080
没有fullField都可以用它来代替了

242
00:54:06,080 --> 00:54:14,670
我们可以放心的删掉参数了

243
00:54:14,670 --> 00:54:22,140
因为使用c#，我可以转换成属性表达式

244
00:54:22,140 --> 00:54:31,470
好的，让我们移动它，好的，不错

245
00:54:31,470 --> 00:54:38,070
让我们返回每个fullfield。
看到了吗？在reserve函数中

246
00:54:38,070 --> 00:54:43,620
我请求给train建造一个reservation attempt。
哦，你没有移动BuildReservation

247
00:54:44,070 --> 00:54:49,110
下面，我把build attemp移动到train中

248
00:54:49,110 --> 00:54:54,150
首先，让我们来移动它，移动到train中，然后请求train

249
00:54:54,150 --> 00:54:57,750
Train, 请根据请求的座位数建造 reservation attempt 

250
00:54:57,750 --> 00:55:02,940
得到了一个 reservation attempt
然后问它是不是满足，如果满足

251
00:55:02,940 --> 00:55:07,620
我会继续请求bookingReference，bookingRef 不是这个领域的

252
00:55:07,620 --> 00:55:13,800
让我们放到领域边界中

253
00:55:13,800 --> 00:55:20,580
我们迭代reservation attempt 中的每个seat

254
00:55:22,170 --> 00:55:28,320
赋值bookingRef。
好的，或许我们可以抽取函数，然后放到reservation attempt 中

255
00:55:28,320 --> 00:55:34,010
在这里赋值bookingRefs

256
00:55:34,010 --> 00:55:40,040
这是一个抽取的例子

257
00:55:40,420 --> 00:55:44,839
我们赋值bookingRefs

258
00:55:44,839 --> 00:55:48,619
好的，我来抽取

259
00:55:48,619 --> 00:55:54,200
这个方法是下一个链，需要被移动

260
00:55:57,619 --> 00:56:02,930
移动bookingRef到reservation attempt中
好的，让我们来看实现

261
00:56:05,210 --> 00:56:09,650
我们获取了bookingRefs，然后赋值给了每一个seat

262
00:56:09,650 --> 00:56:21,020
可以吗?
[观众问题]
我一直在想跟你一样的问题

263
00:56:21,020 --> 00:56:28,010
领域专家确实一直在说，这个过程就是创建一个reservation attempt

264
00:56:28,010 --> 00:56:32,270
今天结束的时候，我们会把它放到reservation attemp中。我有相同的想法

265
00:56:35,670 --> 00:56:40,400
是的。没错

266
00:56:40,400 --> 00:56:47,450
好问题。
实际上，我们常常以为这是要给技术问题

267
00:56:50,390 --> 00:56:55,730
，但是它常常也是领域专家的一个概念。
所以，我们有train caching，用来保存

268
00:56:55,730 --> 00:57:02,000
Wow，好的
或许是时候在程序中建立缓存了

269
00:57:02,000 --> 00:57:08,119
所以你可以缓存东西。
让我们看看是不是相关

270
00:57:08,119 --> 00:57:12,529
relevant here 
可以吗?
我们在 web ticket manager 中有个缓存

271
00:57:12,529 --> 00:57:16,970
然后关联到 web ticket manager 的构造函数中

272
00:57:16,970 --> 00:57:23,930
然后清除它，很有意思，我们清除了它。

273
00:57:23,930 --> 00:57:30,710
这里说明它用了三秒，平均两秒来清除缓存

274
00:57:30,710 --> 00:57:37,099
我不知道这是什么。但是我期望它是这样的。然后我们保存。

275
00:57:37,099 --> 00:57:43,700
是的， bookingReference ， 和train id,  都保存到cache中。
就这样

276
00:57:48,470 --> 00:57:55,880
所以，缓存只是保存东西。

277
00:57:55,880 --> 00:58:02,570
或许可以思考一下
或许是一个没有完成的东西

278
00:58:02,570 --> 00:58:05,720
或许实现了有错误

279
00:58:07,849 --> 00:58:16,609
为什么要缓存topology，这是不错的。它可能被修改

280
00:58:19,250 --> 00:58:25,400
看起来是一些无用的东西，让我们清除掉

281
00:58:25,400 --> 00:58:33,910
我可以移除掉了，移除掉吧。
我感觉好多了
[观众问题]

282
00:58:47,720 --> 00:58:53,000
这是一个我们可以讨论的话题，因为它[领域专家]不在这里

283
00:58:53,000 --> 00:58:56,210
我们以前联系过他，因为这不是第一举行这个会议了

284
00:58:56,210 --> 00:59:01,250
是的，我同意你的观点。有一些东西必须要讨论

285
00:59:01,250 --> 00:59:06,200
不需要讨论技术细节，但是可以记起我们当时的讨论

286
00:59:06,200 --> 00:59:18,170
[Audience Question]
是的，对

287
00:59:18,170 --> 00:59:26,410
我们返回得到train的方法，train data service

288
00:59:26,410 --> 00:59:31,880
然后判断train 的 capacity

289
00:59:31,880 --> 00:59:36,290
我们创建了一个reservation attempt。我们检查它是否满了

290
00:59:36,290 --> 00:59:42,770
检查它是否满了，因为可能没有座位

291
00:59:42,770 --> 00:59:50,000
然后请求bookingReference服务

292
00:59:50,000 --> 00:59:54,200
我们把booking reference赋值给预定的seat上
