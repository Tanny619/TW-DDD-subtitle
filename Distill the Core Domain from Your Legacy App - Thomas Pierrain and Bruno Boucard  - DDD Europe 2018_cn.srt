1
00:00:00,256 --> 00:00:06,400
大家准备好了吗？好了？好，那我们开始。

2
00:00:08,192 --> 00:00:12,800
第一个问题，当把DDD这个概念

3
00:00:13,056 --> 00:00:15,616
运用到项目或者代码里的时候，

4
00:00:15,872 --> 00:00:18,944
你们有谁遇到了困难？

5
00:00:19,968 --> 00:00:26,112
好吧，看来大家都有这样的困惑。我确实

6
00:00:26,368 --> 00:00:28,160
看到过很多关于DDD的讨论。

7
00:00:28,416 --> 00:00:28,928
我

8
00:00:29,184 --> 00:00:32,000
也试过把DDD用在遗留代码上。

9
00:00:34,768 --> 00:00:35,536
这就是我们举行这个会议的原因。

10
00:00:37,120 --> 00:00:43,264
没错。这次我们主要讨论技术模式。

11
00:00:44,032 --> 00:00:50,176
主要讲一下怎样把你的领域知识放到

12
00:00:50,432 --> 00:00:51,456
代码中。

13
00:00:51,712 --> 00:00:54,272
我们也会稍微涉及一些战略模式，不过不会仅限于此。

14
00:00:54,784 --> 00:00:58,112
但是整个会议呢，还是比较

15
00:00:58,368 --> 00:00:59,392
偏向技术的。

16
00:00:59,648 --> 00:01:04,000
我们进行下一步之前先介绍一下自己吧？

17
00:01:06,048 --> 00:01:12,192
嗯好。我是Bruno Boucard。是来自巴黎的讲师。

18
00:01:12,448 --> 00:01:18,080
我教TDD，BDD和DDD。

19
00:01:18,592 --> 00:01:20,640
我现在负责

20
00:01:20,896 --> 00:01:22,688
巴黎的BDD会议。

21
00:01:23,456 --> 00:01:26,784
我是Thomas Pierrain。

22
00:01:27,040 --> 00:01:33,184
我18岁以来就从事软件工作。我也是巴黎DDD会议的组织者之一。

23
00:01:33,440 --> 00:01:35,488
我更倾向于

24
00:01:35,744 --> 00:01:36,512
基于问题。

25
00:01:36,768 --> 00:01:40,096
因为我认为我们太快进入基于解决方案了。

26
00:01:40,352 --> 00:01:42,912
我们周围的好多都是基于解决方案的。

27
00:01:43,424 --> 00:01:45,472
这是我的一个发现。

28
00:01:45,984 --> 00:01:49,056
好，我们为大家准备了

29
00:01:49,568 --> 00:01:50,080
一些礼物。

30
00:01:50,336 --> 00:01:51,872
这有两本书。

31
00:01:52,384 --> 00:01:58,528
蓝色的这本，还有Martin Fowler的重构。

32
00:01:59,808 --> 00:02:03,904
如果想赢得这些书，大家得在会议期间多发推文。

33
00:02:04,160 --> 00:02:10,304
并加上#DDDEU。

34
00:02:10,560 --> 00:02:11,840
我们这有一个裁判。

35
00:02:12,096 --> 00:02:17,216
他到时候会去看这个标签。最有趣的

36
00:02:17,472 --> 00:02:23,616
推文将会获奖。大家可以录像，可以照相，可以开我们的玩笑，也可以开你们自己的玩笑，怎样都行。

37
00:02:23,872 --> 00:02:28,480
John会在会议最后公布最终的两个获奖人。好吗？

38
00:02:30,784 --> 00:02:33,344
我们今天来说说火车领域。

39
00:02:34,624 --> 00:02:40,768
火车领域其实还挺大的。我们今天主要关注怎么来优化座位预定。

40
00:02:42,304 --> 00:02:48,448
这是一个火车模型。这个火车有三个车厢，A，B和C。

41
00:02:48,960 --> 00:02:50,240
橙色的代表

42
00:02:50,496 --> 00:02:53,312
已经被预定的座位。

43
00:02:53,568 --> 00:02:55,104
白色的代表空座位。

44
00:02:55,360 --> 00:02:58,176
现在我们要预定6个座位

45
00:02:58,688 --> 00:03:04,832
蓝色的这6个。这是个比较简单的模型，这个图也有助我们的理解。

46
00:03:05,088 --> 00:03:06,624
好吧。

47
00:03:06,880 --> 00:03:10,720
今天我们的系统有两个业务准则。第一个是

48
00:03:10,976 --> 00:03:15,584
我们最多只能预定火车总座位的70%。

49
00:03:17,120 --> 00:03:20,448
好这是第一个业务规准则。第二个是

50
00:03:20,704 --> 00:03:24,032
当我预定座位时，所有的座位要在同一个车厢。

51
00:03:24,288 --> 00:03:26,848
谁也不想家人朋友坐在

52
00:03:27,104 --> 00:03:29,920
不同的车厢。对吧？

53
00:03:30,176 --> 00:03:30,688
就这么简单。

54
00:03:30,944 --> 00:03:34,784
我们是从Emily Bache火车预订那里得到这些准则的。

55
00:03:35,296 --> 00:03:39,392
我们这还有一些用来实现这些规则的代码。

56
00:03:40,160 --> 00:03:46,304
我们的领域专家今天不能跟我们一起来到阿马斯特丹，不过前几周，

57
00:03:46,560 --> 00:03:47,840
我们和他谈了很多。

58
00:03:48,096 --> 00:03:49,632
他谈了很多火车相关的话题。

59
00:03:50,144 --> 00:03:53,984
他谈了火车ID、火车座位，

60
00:03:54,496 --> 00:03:55,264
火车车厢之类的。

61
00:03:56,288 --> 00:04:02,432
还谈了预定，还有这些预定有没有成功。

62
00:04:02,688 --> 00:04:06,784
如果我准备订票，还得有订票功能。

63
00:04:07,808 --> 00:04:09,600
我们之前已经解释了什么是订票单据。

64
00:04:10,368 --> 00:04:12,672
什么是预定，什么是预定失败。

65
00:04:13,184 --> 00:04:19,327
这是专家的用词。对，我们之前的交流，

66
00:04:19,583 --> 00:04:20,095
用的就是这些词。

67
00:04:22,399 --> 00:04:28,543
我们将会为一个名为Train Train的初创公司工作。他们提供

68
00:04:28,799 --> 00:04:32,127
座位预定服务，是个web API。

69
00:04:32,383 --> 00:04:36,479
这个web API还依赖于

70
00:04:36,735 --> 00:04:39,295
其他公司提供的后端支持。

71
00:04:39,807 --> 00:04:42,111
也就是SNCF。

72
00:04:42,367 --> 00:04:44,927
SNCF提供的第一个后端支持

73
00:04:45,439 --> 00:04:48,255
是Train Data。

74
00:04:48,767 --> 00:04:49,791
它就是一个

75
00:04:50,047 --> 00:04:51,327
火车拓扑服务。

76
00:04:51,583 --> 00:04:54,143
也就是说我们给他一个火车事件，

77
00:04:54,655 --> 00:04:56,959
我们可以就得到火车拓扑，比如

78
00:04:57,215 --> 00:05:03,359
所有的车厢，每一个车厢里的所有座位，每一个座位是可以预定的状态，

79
00:05:03,615 --> 00:05:04,639
还是已经被预定了。

80
00:05:05,919 --> 00:05:06,431
对，还有数量。

81
00:05:07,199 --> 00:05:13,343
第二个是订票单据。这个有点麻烦...也不麻烦

82
00:05:13,599 --> 00:05:14,623
当你买完票，你的火车票上就会有一个ID。

83
00:05:14,879 --> 00:05:21,023
就是这个意思。对。这就是一个只提供ID的服务。

84
00:05:21,279 --> 00:05:22,047
我们用它

85
00:05:22,303 --> 00:05:23,583
来订票。

86
00:05:24,095 --> 00:05:27,423
我们用它只是

87
00:05:27,679 --> 00:05:28,447
得到一个ID

88
00:05:29,215 --> 00:05:35,359
当左边的预定服务拿到火车拓扑后，我们就能找到可选的座位，

89
00:05:35,615 --> 00:05:36,127
然后

90
00:05:36,383 --> 00:05:39,199
可以拿到一个订票单据，我们其实是

91
00:05:39,711 --> 00:05:40,735
通过

92
00:05:40,991 --> 00:05:43,039
国家列车运营服务来订票的。

93
00:05:43,295 --> 00:05:45,855
就是通过最下面的这个火车订票服务。

94
00:05:46,367 --> 00:05:52,511
好吧？我们是一个初创公司，在这个刚开放的市场中

95
00:05:52,767 --> 00:05:58,655
还处于下游。这些后端的服务是国家列车运营服务提供的。

96
00:05:59,167 --> 00:06:00,447
到现在大家有什么问题吗？

97
00:06:01,727 --> 00:06:02,495
那我们继续。

98
00:06:03,519 --> 00:06:07,615
Bruno现在可以演示一下Web API。

99
00:06:10,175 --> 00:06:10,943
需要

100
00:06:11,199 --> 00:06:12,223
几秒钟

101
00:06:12,479 --> 00:06:13,247
才能转换屏幕。

102
00:06:16,575 --> 00:06:17,855
嗯

103
00:06:18,111 --> 00:06:19,903
我用的是postman，

104
00:06:20,159 --> 00:06:27,231
你可以看到我调用Web API时的url。

105
00:06:27,327 --> 00:06:29,375
我们还能看到请求体

106
00:06:29,631 --> 00:06:33,471
有两个值。

107
00:06:33,727 --> 00:06:36,031
Train_id是火车的ID。

108
00:06:36,287 --> 00:06:39,359
还有请求的座位数量number_of_seats。

109
00:06:40,127 --> 00:06:40,639
好

110
00:06:42,431 --> 00:06:43,711
如果你发送请求。

111
00:06:43,967 --> 00:06:45,247
没错。

112
00:06:45,759 --> 00:06:46,527
需要等一会。

113
00:06:50,367 --> 00:06:53,695
还在加载。好现在我们得到了响应。

114
00:06:53,951 --> 00:06:54,975
这就是响应。

115
00:06:55,231 --> 00:06:57,023
第一个是train_id。

116
00:06:57,535 --> 00:06:58,047
对吧？

117
00:06:58,303 --> 00:07:00,351
第二个是订票单据。

118
00:07:00,607 --> 00:07:03,423
是通过我们之前说的那个服务得到的。

119
00:07:03,679 --> 00:07:05,215
然后我们得到了

120
00:07:05,983 --> 00:07:11,031
座位的列表。

121
00:07:13,151 --> 00:07:17,503
好，我们的系统还挺简单的，对。

122
00:07:25,183 --> 00:07:30,559
不过我们有一个问题，这也是为什么我们今天在这里。

123
00:07:31,071 --> 00:07:35,935
Train Train公司找到我们，说一直都在面临着一个问题。

124
00:07:36,447 --> 00:07:41,311
国家列车运营服务给他们带来的问题。

125
00:07:42,079 --> 00:07:43,103
什么问题呢？

126
00:07:43,359 --> 00:07:44,383
每一次调用

127
00:07:44,895 --> 00:07:49,759
后端服务的时候，都是收费的。这对Train Train这个初创公司意味着

128
00:07:50,271 --> 00:07:55,647
每次调用这些web API都要钱。

129
00:07:55,903 --> 00:07:57,439
他们知道这些调用是要钱的，

130
00:07:57,695 --> 00:07:58,719
但是

131
00:07:59,231 --> 00:08:01,023
他们觉得还是太贵了。

132
00:08:01,279 --> 00:08:03,327
因此他们让我们来看一下代码。

133
00:08:03,583 --> 00:08:04,351
来看看

134
00:08:04,607 --> 00:08:08,447
到底是为什么，看看我们能不能找到它，如果有什么要修复的话，

135
00:08:08,703 --> 00:08:09,983
看看能不能修复。

136
00:08:11,519 --> 00:08:17,407
好吧？但是在我们着手遗留代码之前，如果你...
大家建议我和Bruno

137
00:08:19,455 --> 00:08:20,223
应该先干什么？

138
00:08:22,015 --> 00:08:23,807
（测试？）测试，没错。

139
00:08:24,319 --> 00:08:29,439
事实上，这就是我们错过主题演讲的原因。今天早上我们对此进行了一些测试。

140
00:08:30,207 --> 00:08:33,023
查看代码，试着凸显

141
00:08:33,279 --> 00:08:38,655
那些业务准则。到现在为止我们写了三个测试。

142
00:08:39,167 --> 00:08:44,543
第一个测试通过了。我们建了一个只有一个车厢

143
00:08:45,055 --> 00:08:49,151
一共10个座的火车。我们想预定3个座位。

144
00:08:49,407 --> 00:08:52,991
你看这就是我用postman做的，响应也都一样。

145
00:08:57,855 --> 00:08:59,391
通过。

146
00:09:00,159 --> 00:09:01,695
第二个测试是

147
00:09:02,207 --> 00:09:08,351
对这是第一个业务准则。我们对预定不能超过

148
00:09:08,607 --> 00:09:14,751
所有座位的70%。如果我们现在想预定2个座位，

149
00:09:15,007 --> 00:09:16,543
现在我们已经订出去了6个座位了，

150
00:09:17,567 --> 00:09:18,335
这里

151
00:09:19,871 --> 00:09:22,431
因为这个准则，

152
00:09:22,943 --> 00:09:28,831
70%也就是只有7个座位可以被预定。没错。所以是这么响应

153
00:09:29,343 --> 00:09:30,111
这个错误的。

154
00:09:30,623 --> 00:09:33,183
我能得到火车的ID，但是订票单据是空的。

155
00:09:33,439 --> 00:09:34,975
而且座位列表也是空的。

156
00:09:35,487 --> 00:09:38,047
用这种方式，Train Train告诉我们，我们没有

157
00:09:38,559 --> 00:09:40,095
预定任何座位。

158
00:09:41,375 --> 00:09:41,887
好。

159
00:09:42,143 --> 00:09:48,031
第三个测试是...所有的预定必须是在同一个车厢里。

160
00:09:48,543 --> 00:09:49,823
这是第二个业务准则。

161
00:09:50,079 --> 00:09:53,663
这种情况下我们找到了bug，因为我们这有

162
00:09:54,175 --> 00:10:00,319
一个两节车厢的火车。一节车厢基本上满了。

163
00:10:00,831 --> 00:10:03,135
另一节车厢完全是空的。当我们想订2个座位时，

164
00:10:03,647 --> 00:10:09,279
我们得到的是这个结果。两个车厢一边一个座位，这不是我们想要的，

165
00:10:09,535 --> 00:10:11,071
因为我们让家人朋友分开了。

166
00:10:11,839 --> 00:10:14,143
我们正在考虑的这个问题。Bruno说

167
00:10:15,423 --> 00:10:18,239
这结果也许解释了一些事。

168
00:10:18,495 --> 00:10:21,567
大家可能想到了这个结果会导致什么。

169
00:10:23,871 --> 00:10:25,407
试想你用

170
00:10:25,663 --> 00:10:26,431
网站订票

171
00:10:26,943 --> 00:10:28,223
你调用了后端的服务。

172
00:10:29,247 --> 00:10:31,039
你准备跟家人

173
00:10:31,295 --> 00:10:33,087
或者你的女朋友，男朋友

174
00:10:33,855 --> 00:10:35,391
一起旅行。

175
00:10:36,183 --> 00:10:40,183
会发生什么？（也许你就会取消这个预定了，因为你不能跟朋友坐一起了。）

176
00:10:41,279 --> 00:10:45,375
没错，这会导致人们取消预定。

177
00:10:45,631 --> 00:10:52,263
因为我可不想俩座位分别在俩车厢。我也许会取消了再订一次试试。

178
00:10:52,543 --> 00:10:57,663
取消重新订，再取消，再订，最后可能我就会换一个别的地方订票了。

179
00:10:57,919 --> 00:10:58,943
就不用Train Train了。

180
00:10:59,199 --> 00:11:00,479
因为用户体验太差。

181
00:11:00,735 --> 00:11:05,087
这也解释了为什么Train Train会觉得服务很贵，因为每一次预定都会被收费。

182
00:11:05,599 --> 00:11:08,671
这是我们的假设。

183
00:11:09,183 --> 00:11:12,511
我们跟领域专家讨论过。他说，是啊

184
00:11:12,767 --> 00:11:16,351
也许得找个新的方案，拜托

185
00:11:16,863 --> 00:11:18,399
你们要修好这个bug啊。

186
00:11:18,655 --> 00:11:23,519
所以，我们现在要一起修好这个bug。我们也会在这个过程中寻求大家的帮助。

187
00:11:25,055 --> 00:11:27,103
大家现在有什么建议吗？

188
00:11:27,359 --> 00:11:40,639
你们的策略是什么？（预定的那个服务是从Train Data那个服务拿数据吗？）

189
00:11:41,439 --> 00:11:47,327
我们是左边橙色的这个火车票预定服务。这个，我来...

190
00:11:49,119 --> 00:11:52,703
我们现在只管黄色的这个座位预定。

191
00:11:53,727 --> 00:11:59,055
这些都是依赖。我们其实没法控制。（是只有我们用这些服务吗？）

192
00:12:00,127 --> 00:12:06,271
不，我们和其他公司一起竞争。我们是一个初创公司，我们要跟别人竞争。

193
00:12:06,527 --> 00:12:11,391
我们需要从那俩服务获取信息，我们还得设置信息、确认信息、

194
00:12:11,647 --> 00:12:12,159
还要订票，

195
00:12:12,671 --> 00:12:14,463
用它来交易。

196
00:12:14,975 --> 00:12:15,487
所以

197
00:12:15,999 --> 00:12:17,279
这就是我们能做的操作。

198
00:12:19,327 --> 00:12:23,143
那现在还有什么建议吗？（写测试？）

199
00:12:23,679 --> 00:12:24,191
写测试。

200
00:12:24,447 --> 00:12:25,215
没错，写测试。

201
00:12:25,471 --> 00:12:31,615
其实我们已经写好了2个测试，来凸显这个bug。我们要修这个bug了。

202
00:12:33,663 --> 00:12:35,711
那我们看看代码吧。

203
00:12:35,967 --> 00:12:36,735
Bruno已经

204
00:12:37,247 --> 00:12:38,271
设了几个断点

205
00:12:39,807 --> 00:12:40,575
我们可以在这调用一下。没错，要等一小会儿。

206
00:12:43,135 --> 00:12:44,415
现在正在触发这个bug。

207
00:12:45,951 --> 00:12:47,743
这块，

208
00:12:48,255 --> 00:12:51,071
稍微向左移一下屏幕。

209
00:12:51,583 --> 00:12:56,447
这是个C#代码，用的是asp.net的API。

210
00:12:56,703 --> 00:13:02,847
这对于用Java Spring Boot的人来说比较简单。当我们用那个名字

211
00:13:03,103 --> 00:13:04,127
请求网络服务时

212
00:13:04,383 --> 00:13:07,455
我们可以得到响应。

213
00:13:08,479 --> 00:13:12,575
我们得到了ReservationRequestDto。

214
00:13:13,087 --> 00:13:18,975
看一下这个Dto，这个很简单，跟JSON完全一样。

215
00:13:19,743 --> 00:13:20,511
没错。

216
00:13:22,559 --> 00:13:28,703
然后我们安装了它，往左移一下屏幕，谢谢。你看我们安装了

217
00:13:28,959 --> 00:13:33,567
webTicketManager，是这个系统的入口。我们会调用

218
00:13:34,079 --> 00:13:35,103
它上面的预定方法。

219
00:13:35,359 --> 00:13:36,895
把train_id和预定的座位数当作参数。

220
00:13:38,943 --> 00:13:39,967
好了

221
00:13:40,735 --> 00:13:44,063
这就是我们目前的测试。

222
00:13:44,575 --> 00:13:47,135
我们可以看一下这些测试，这些挂了。

223
00:13:49,951 --> 00:13:50,719
我们一共有3个测试。

224
00:13:51,743 --> 00:13:54,815
这就像是异常测试，我们把这些当作black bug。

225
00:13:55,583 --> 00:13:59,167
如果我们发送这些请求，然后查看

226
00:14:00,703 --> 00:14:01,727
一下json数据

227
00:14:01,983 --> 00:14:03,775
最后一个测试，

228
00:14:04,031 --> 00:14:05,823
我们就可以看出这个问题。是吧？

229
00:14:06,079 --> 00:14:11,199
稍等，我们有一个工具。每当我们做改变的时候，

230
00:14:11,455 --> 00:14:17,599
我们输入一些东西，改变代码，它会在后台自动跑测试。

231
00:14:17,855 --> 00:14:23,999
然后左边会有有颜色的箭头，是给我们反馈。

232
00:14:24,255 --> 00:14:26,303
绿色代表没问题，红色

233
00:14:26,559 --> 00:14:30,399
代表有问题。这就有个红箭头。

234
00:14:30,911 --> 00:14:31,423
Bruno，你来...

235
00:14:31,679 --> 00:14:33,983
好我来展示。看看这个错误。

236
00:14:35,007 --> 00:14:39,103
这问题是，我们本来想要2个座位，

237
00:14:39,615 --> 00:14:42,431
1B和2B，但是我们得到的却是

238
00:14:42,943 --> 00:14:47,295
10A和1B。这是我们之前就讨论过的bug。

239
00:14:48,575 --> 00:14:50,111
对吧？

240
00:14:50,879 --> 00:14:57,023
我觉得现在最好停一下，我们再看看这个Reserve方法在干什么。

241
00:14:57,279 --> 00:15:01,119
我帮你找一下代码。

242
00:15:01,631 --> 00:15:07,519
我们先看一下。我们今天早上的时候看过了一次，所以

243
00:15:07,775 --> 00:15:12,383
我们可能更熟悉这段代码。我们会帮大家

244
00:15:12,639 --> 00:15:13,663
过一遍这代码。

245
00:15:14,431 --> 00:15:20,575
首先我们有一个可选座位的列表。这应该是

246
00:15:20,831 --> 00:15:22,367
这个方法的结果。

247
00:15:22,879 --> 00:15:25,695
然后我们调用trainDataService上的get train方法。

248
00:15:26,207 --> 00:15:32,351
我们就得到了jsonTrain这个数据。这也许是json拓扑，我们以后再看。

249
00:15:33,631 --> 00:15:39,751
然后我们就得到了train，一个火车拓扑。

250
00:15:40,287 --> 00:15:44,895
得到train之后，我们需要添加一些业务准则。

251
00:15:45,407 --> 00:15:51,551
如果被预定的座位数加上我想预定的座位数，

252
00:15:52,063 --> 00:15:53,087
低于

253
00:15:53,599 --> 00:15:56,159
低于GetMaxRes这个数，我看一下，

254
00:15:56,415 --> 00:16:00,511
应该是个百分数吧。对，70%。

255
00:16:01,023 --> 00:16:01,535
好。

256
00:16:01,791 --> 00:16:04,815
火车总座位数的70%。

257
00:16:04,863 --> 00:16:05,887
如果

258
00:16:06,143 --> 00:16:09,983
我们符合这个业务准则，那么我就可以继续。

259
00:16:10,751 --> 00:16:15,871
继续之后，numberOfReserv感觉像是个累加变量。

260
00:16:16,127 --> 00:16:18,431
我们想找到可选的座位。

261
00:16:19,199 --> 00:16:24,575
可选座位指的是系统里面BookingRef为空的座位。

262
00:16:25,087 --> 00:16:29,951
我们这有个属性，如果它为空的话，

263
00:16:30,463 --> 00:16:32,255
就代表这个座位可选。

264
00:16:32,511 --> 00:16:33,791
然后我们就可以把它加入到

265
00:16:34,047 --> 00:16:34,815
座位列表里。

266
00:16:35,071 --> 00:16:37,887
就是方法最后我们要返回的列表。

267
00:16:38,399 --> 00:16:39,679
到现在都还跟得上吧大家？

268
00:16:41,471 --> 00:16:46,079
然后这还有一些愚蠢的forEach，我们几年都没有看到过这个了。

269
00:16:46,335 --> 00:16:50,175
如果我们没有那么多可被预定的座位

270
00:16:50,943 --> 00:16:56,063
怎么办？我们会得到一个响应。

271
00:16:56,319 --> 00:16:59,135
告诉你不可以预定了。

272
00:16:59,647 --> 00:17:03,231
这个可是一个失败的消息啊。

273
00:17:03,743 --> 00:17:09,887
如果座位预定好了，我们会调用bookingReferenceService，就是在右边中间部分的这个。

274
00:17:10,911 --> 00:17:12,447
然后调用GetBookingReference。

275
00:17:13,983 --> 00:17:15,007
然后我们

276
00:17:15,263 --> 00:17:19,615
给每一个可预定的座位附上一个订票收据。

277
00:17:20,383 --> 00:17:21,151
到现在为止

278
00:17:21,407 --> 00:17:23,967
我们有很多的累加器。

279
00:17:24,479 --> 00:17:26,271
然后这里，又有一个

280
00:17:26,527 --> 00:17:32,671
跟之前基本一样的if。你看之前的。对确实像的。不对，第一个条件是不等。

281
00:17:32,927 --> 00:17:33,951
不完全一样。

282
00:17:34,207 --> 00:17:40,351
如果条件还满足的话...哦我们这还用了cache？是啊，有意思。

283
00:17:40,863 --> 00:17:42,399
我们等会再看看这是为什么，好吧？

284
00:17:42,655 --> 00:17:48,799
然后我们会干什么...这其实是在订票。

285
00:17:49,055 --> 00:17:49,567
其实就是交易。

286
00:17:49,823 --> 00:17:54,175
订票的话我们调用的是一个外部的web API。

287
00:17:54,687 --> 00:17:55,455
如果我

288
00:17:55,967 --> 00:17:56,991
进入这个的话

289
00:17:58,527 --> 00:17:59,295
我看一下

290
00:17:59,551 --> 00:18:01,343
here the implemetation.
这是它的实现。

291
00:18:01,599 --> 00:18:07,231
对我们就是调用了一个web API。

292
00:18:07,487 --> 00:18:09,399
有点意思。

293
00:18:09,535 --> 00:18:13,375
如果这没什么异常的话，

294
00:18:13,887 --> 00:18:16,447
我们会返回一个数据。

295
00:18:17,983 --> 00:18:21,567
返回值就是到目前为止我们找到的

296
00:18:22,079 --> 00:18:24,127
座位列表。都没什么问题吧？

297
00:18:24,639 --> 00:18:30,783
这里在干什么来着？哦对，如果预定座位数超过

298
00:18:31,039 --> 00:18:33,343
火车总座位数的话，

299
00:18:33,599 --> 00:18:38,719
我们返回一个空值。你就不能预定了。预定失败了。

300
00:18:39,743 --> 00:18:41,279
对吧？

301
00:18:42,559 --> 00:18:45,631
我们之后还会回过头再看一下这里，不过

302
00:18:45,887 --> 00:18:47,167
现在大家有什么

303
00:18:47,679 --> 00:18:49,703
疑问吗？

304
00:18:49,471 --> 00:18:54,971
（你们为什么用字符串连接来创建json？）

305
00:18:55,103 --> 00:18:57,919
我们为什么用字符串连接来创建json？

306
00:18:59,199 --> 00:19:00,479
其实这也不是我们自己写的代码。

307
00:19:00,735 --> 00:19:06,879
先声明一下，这是客户的代码，今天早上才成为我们客户的。不过你说的很对。我们为什么

308
00:19:09,695 --> 00:19:15,839
要在这里加json呢？这里应该是有一些

309
00:19:16,095 --> 00:19:17,119
业务逻辑吧。

310
00:19:19,935 --> 00:19:26,079
（用github link证明一下你刚才说的呗？） 我们在这个项目里都没用到git。

311
00:19:26,335 --> 00:19:34,151
我没法证明啊。（我觉得是不是应该把业务逻辑放在一个方法里啊？）

312
00:19:34,215 --> 00:19:35,807
没错。

313
00:19:36,063 --> 00:19:37,855
对，确实是。

314
00:19:38,367 --> 00:19:44,255
我们以后可以试试你的这个建议。我们会试着

315
00:19:45,791 --> 00:19:49,327
通过代码去了解火车领域的概念。

316
00:19:50,143 --> 00:19:55,775
我们试图弄清楚如何才能改进这个代码，因为到目前为止，有些东西真的挺让我烦恼的。

317
00:19:57,055 --> 00:20:00,347
我们刚才说的那个领域专家，

318
00:20:00,639 --> 00:20:02,687
跟我们讲理很多的概念。

319
00:20:03,967 --> 00:20:06,783
除了火车的概念

320
00:20:07,039 --> 00:20:10,367
座位的概念，你们还能看出

321
00:20:10,623 --> 00:20:12,991
其他的概念吗？

322
00:20:13,183 --> 00:20:16,463
有些东西是缺失的。（这没有车厢的概念。）

323
00:20:16,511 --> 00:20:19,839
没错，车厢的概念完全缺失了。

324
00:20:20,095 --> 00:20:22,631
其他的呢？（预定的概念？）

325
00:20:22,655 --> 00:20:27,775
预定，没错。到现在为止，没有预定的概念。

326
00:20:28,031 --> 00:20:30,591
大家谁之前有看过类似这样的代码？

327
00:20:32,127 --> 00:20:33,151
看来有人遇到过啊。

328
00:20:34,943 --> 00:20:41,087
看来并不是只有我们遇到了这个问题。对所有在座的人来说，今天我们要找出一个方式

329
00:20:41,343 --> 00:20:42,111
来改进这个代码。

330
00:20:42,367 --> 00:20:43,135
因为

331
00:20:43,391 --> 00:20:46,463
因为现在我们这没有指导，

332
00:20:46,719 --> 00:20:52,559
我们来修bug的策略就是先看懂它。

333
00:20:52,863 --> 00:20:54,655
但在那之前，

334
00:20:54,911 --> 00:20:57,471
这有好多糟糕的代码啊。

335
00:20:57,727 --> 00:20:59,007
我们先清理一下。

336
00:20:59,263 --> 00:21:00,799
先Clean the deck？是的。

337
00:21:01,055 --> 00:21:03,103
你们知道Clean the deck是什么吗？

338
00:21:03,359 --> 00:21:04,895
Clean the deck这种说法？不知道？

339
00:21:05,407 --> 00:21:06,943
Clean the deck

340
00:21:07,455 --> 00:21:10,527
是你检测代码的第一步

341
00:21:10,783 --> 00:21:14,367
因为在做深度重构之前，你必须

342
00:21:14,623 --> 00:21:18,208
让自己更有信心。

343
00:21:18,464 --> 00:21:23,280
这是检测代码的一种方式，从小的地方去修复代码，

344
00:21:24,096 --> 00:21:25,888
就比如变量名字啊。

345
00:21:26,656 --> 00:21:27,424
这之后，

346
00:21:28,192 --> 00:21:34,336
再继续编程。是的，这就是我们在脑海里准备一个心理模型的方式。

347
00:21:35,992 --> 00:21:40,736
好那我们回到刚才，开始Clean the deck。大家一点一点的去改进，

348
00:21:40,992 --> 00:21:42,272
就会有一个新的理解。

349
00:21:42,528 --> 00:21:45,344
稍等，我看有人有问题。

350
00:21:47,392 --> 00:21:53,024
（你63行有个拼写错误。） 63行有个错？哦对，没错。这就是遗留代码啊。

351
00:21:54,560 --> 00:21:56,864
不过你注意到了没有这里有点问题？我们得修复它。

352
00:21:57,888 --> 00:21:58,912
这红了。

353
00:21:59,424 --> 00:22:00,704
如果我们代码红了，

354
00:22:01,472 --> 00:22:05,568
我很难有信心去修改它。因为如果

355
00:22:05,824 --> 00:22:06,592
改的时候出错了，

356
00:22:07,104 --> 00:22:10,176
我根本不知道出错了。我还是更喜欢看到这里的代码

357
00:22:10,688 --> 00:22:11,968
都是绿色的。

358
00:22:12,480 --> 00:22:13,248
为了让它变绿，

359
00:22:14,016 --> 00:22:17,600
我们要完全忽略这个测试，先去找bug。

360
00:22:18,112 --> 00:22:19,136
这是一个很好的技巧

361
00:22:19,392 --> 00:22:22,720
如果你也面临着测试挂了的这种情况，

362
00:22:23,488 --> 00:22:26,304
你需要先重构再修bug，

363
00:22:26,816 --> 00:22:30,400
你最好就先忽略那个测试。

364
00:22:30,656 --> 00:22:36,800
现在变绿了，我们这也还有一个测试。我们可以先重构，然后启用这个测试，再去修复bug。

365
00:22:37,568 --> 00:22:39,080
这其实就是

366
00:22:39,360 --> 00:22:40,896
你现在做的。白色

367
00:22:41,152 --> 00:22:50,784
意味着我们不跑这个测试。现在我就可以开始了。（我有个问题。如果我们

368
00:22:51,392 --> 00:22:51,904
新建一个测试，来测试当前的行为，

369
00:22:56,000 --> 00:22:57,024
是不是更好？

370
00:22:58,560 --> 00:23:00,608
因为当你重构的时候，你还是想

371
00:23:02,144 --> 00:23:04,192
保留当前的行为的。）是的。

372
00:23:05,216 --> 00:23:09,568
（新建一个测试的话，我们忽略掉旧的测试。）没错。（新建的测试就测

373
00:23:12,128 --> 00:23:13,664
当前的行为，我们得通过这个新测试才行。）

374
00:23:15,200 --> 00:23:19,552
是的，这是Golden master，是我很喜欢的一个技巧。

375
00:23:20,064 --> 00:23:21,856
Golden master是你拿到一个遗留代码，

376
00:23:22,368 --> 00:23:23,136
复制这个代码，

377
00:23:23,648 --> 00:23:27,232
然后去写验收测试。

378
00:23:27,488 --> 00:23:34,632
每当我将输入发送到遗留代码和新写的代码时，

379
00:23:34,656 --> 00:23:37,216
我得到的两个输出

380
00:23:37,472 --> 00:23:39,264
应该一样。

381
00:23:39,520 --> 00:23:40,800
所以即使

382
00:23:41,056 --> 00:23:43,616
不知道代码的上下文，

383
00:23:43,872 --> 00:23:45,152
我依然可以有这个测试。

384
00:23:45,408 --> 00:23:50,528
这也强迫我，不要影响现有的行为。

385
00:23:51,040 --> 00:23:57,184
我们本来应该这么做的，不过现在我们在实现业务准则，

386
00:23:57,440 --> 00:23:58,976
所以作为领域专家，

387
00:23:59,488 --> 00:24:05,632
我们就先用现有的代码。不过你说的那个确实是重构的好方法。

388
00:24:07,168 --> 00:24:08,704
Bruno，继续clean the deck吧。

389
00:24:08,960 --> 00:24:10,752
我们可以看到，

390
00:24:11,776 --> 00:24:17,056
这第一个变量，seat。

391
00:24:17,920 --> 00:24:20,444
我要看一下

392
00:24:20,736 --> 00:24:23,808
在哪用了它。离调用的地方很远啊。是啊，确实远。

393
00:24:24,576 --> 00:24:25,088
那...

394
00:24:26,880 --> 00:24:27,904
也许

395
00:24:29,952 --> 00:24:32,768
我可以把它移的

396
00:24:33,280 --> 00:24:35,328
离调用的地方近一点的。

397
00:24:37,632 --> 00:24:40,704
比如放这。后面的人你们看得到所有的代码吗？

398
00:24:40,960 --> 00:24:47,104
我的测试是实时运行的，所以我知道我没有破坏现有的代码。这都是绿色的。

399
00:24:48,896 --> 00:24:55,040
我是个C语言程序员，C语言的程序员一般习惯

400
00:24:55,296 --> 00:24:58,112
把所有变量都写在代码的最前面。

401
00:24:58,368 --> 00:24:59,904
所以这是你写的代码？

402
00:25:00,160 --> 00:25:06,304
不，不是我写的。好，第二个变量是count。

403
00:25:07,840 --> 00:25:10,656
count，这名字起的。

404
00:25:11,424 --> 00:25:12,448
是啊，count。

405
00:25:13,984 --> 00:25:17,568
这又是个愚蠢的循环。是啊，我们在list里循环。

406
00:25:17,824 --> 00:25:19,872
这其实是count的list。

407
00:25:20,128 --> 00:25:22,432
完全是一样的数字啊。

408
00:25:22,688 --> 00:25:28,832
这有个提示，这个没被用过。它是不是想告诉我们点什么？

409
00:25:29,392 --> 00:25:34,208
我应该可以用

410
00:25:34,720 --> 00:25:35,488
availabelSeats

411
00:25:35,744 --> 00:25:36,512
赋值给count。

412
00:25:36,768 --> 00:25:40,864
对，因为这个循环最后，count和availableSeats的值

413
00:25:41,120 --> 00:25:43,680
是一样的。我现在可以删了这个。

414
00:25:43,936 --> 00:25:44,448
好了。

415
00:25:45,216 --> 00:25:46,240
好，就先这样。

416
00:25:46,496 --> 00:25:50,848
现在，我们可以看一下，这方法占几个屏幕。

417
00:25:51,616 --> 00:25:52,640
一，二

418
00:25:53,664 --> 00:25:54,176
两个

419
00:25:54,432 --> 00:25:56,736
两个半？对，两个半。

420
00:25:57,504 --> 00:26:00,576
这其实也是另一个困扰我的事情，方法太长了。

421
00:26:01,344 --> 00:26:02,112
好吧。

422
00:26:03,392 --> 00:26:10,536
好，这是火车拓扑的代码。

423
00:26:11,072 --> 00:26:12,352
没准我们可以重命名？

424
00:26:14,400 --> 00:26:15,424
可以啊。

425
00:26:15,680 --> 00:26:16,192
Train topology?

426
00:26:16,448 --> 00:26:17,216
嗯可以。

427
00:26:17,472 --> 00:26:23,616
Traintopol然后...拓扑这个词挺好，我们刚才一直都在说

428
00:26:23,872 --> 00:26:30,016
火车拓扑嘛。对，确实比之前那个好。那这个词，trainInst。

429
00:26:30,528 --> 00:26:32,320
指令？还是实例？

430
00:26:32,832 --> 00:26:37,952
我们问了领域专家，他说领域里没有火车实例的概念。

431
00:26:38,464 --> 00:26:44,352
所以这个可能是train install？那我把它改成train吧。所以现在我们从火车拓扑，得到一个火车。不错。

432
00:26:45,632 --> 00:26:48,192
这是什么？

433
00:26:48,448 --> 00:26:52,032
numberOfReserv。也许你应该

434
00:26:52,288 --> 00:26:57,152
把它放这边，这样后面的人能看清所有的代码。好的，你们看这个。

435
00:26:58,944 --> 00:27:02,272
numberOfReserv。这个被用过吗？没有吧？。

436
00:27:03,040 --> 00:27:05,088
这就是个形式而已啊。

437
00:27:05,344 --> 00:27:09,696
我们这个变量

438
00:27:09,952 --> 00:27:16,096
没有什么用。只是为了计算，以防我们的计数是错的。

439
00:27:16,352 --> 00:27:19,936
也许这个是故意的？我也不知道。

440
00:27:20,192 --> 00:27:24,776
我们其实不用去理解这个。这些乱七八糟的。

441
00:27:26,848 --> 00:27:29,408
好，我可以把这个删了。

442
00:27:29,664 --> 00:27:32,480
那你不要这个了？对不要了。

443
00:27:35,040 --> 00:27:35,808
那你可以删了它。

444
00:27:36,064 --> 00:27:36,576
是的。

445
00:27:36,832 --> 00:27:42,976
呃...这个each

446
00:27:43,232 --> 00:27:47,840
应该是seat。对，从seat的collection中我们得到的是seat。

447
00:27:48,608 --> 00:27:53,216
这有个小错误，应该是reservedSet。

448
00:27:53,728 --> 00:27:59,872
我们没有集合的概念。我们问过领域专家到底有没有集合的概念？他们说没有。这又有一个循环。

449
00:28:03,968 --> 00:28:04,992
但是没被用过。

450
00:28:06,272 --> 00:28:07,808
谁之前也在代码里遇见过这种

451
00:28:08,064 --> 00:28:13,696
根本没被用过的变量、声明之类的？

452
00:28:14,976 --> 00:28:16,512
对。遗留代码里

453
00:28:16,768 --> 00:28:18,280
很多这种东西。

454
00:28:18,816 --> 00:28:21,376
这有点污染我们的头脑。

455
00:28:23,424 --> 00:28:24,704
这个。

456
00:28:24,960 --> 00:28:27,008
看看这个。我们这有

457
00:28:29,056 --> 00:28:32,896
一个if。然后我们在这又有一个差不多的if。

458
00:28:34,176 --> 00:28:35,200
是，那我...

459
00:28:35,456 --> 00:28:44,600
我们喜欢对称性，这有利于我们去相互比较。为了这么做，我们建议把第一个if逻辑反转一下。对这是个好主意。

460
00:28:44,928 --> 00:28:47,232
反转这个if逻辑。然后

461
00:28:47,488 --> 00:28:50,304
你看这些都差不多一样...

462
00:28:51,328 --> 00:28:53,632
我要选中...等一下

463
00:28:53,888 --> 00:28:54,656
我们看一下。

464
00:28:56,192 --> 00:28:58,752
这，你看有一个if。这里。

465
00:29:00,032 --> 00:29:02,080
这又有一个差不多的。

466
00:29:02,592 --> 00:29:08,224
因为中间什么也没有，我们可以把下面if里的代码剪切，

467
00:29:08,480 --> 00:29:11,552
粘贴到第一个if到后面。

468
00:29:11,808 --> 00:29:14,880
这个，就在它后面，这样也符合算法逻辑。

469
00:29:16,928 --> 00:29:17,440
然后

470
00:29:18,976 --> 00:29:22,560
这也会简化一点代码结构。

471
00:29:22,816 --> 00:29:26,912
这确实不错。都是绿的你看。

472
00:29:27,936 --> 00:29:28,448
现在我们可以...看一下

473
00:29:28,704 --> 00:29:34,848
你为什么那么做？因为，它是白色的。对，当代码

474
00:29:35,104 --> 00:29:36,640
没被覆盖，

475
00:29:38,432 --> 00:29:38,944
这会有一个白色的

476
00:29:39,200 --> 00:29:40,480
标识符

477
00:29:41,248 --> 00:29:42,016
这对我们来说

478
00:29:42,528 --> 00:29:45,600
挺好的。这个也没有什么必要。

479
00:29:48,160 --> 00:29:50,464
对你可以把这几行删了。

480
00:29:50,720 --> 00:29:52,256
我觉得我们

481
00:29:52,512 --> 00:29:58,144
有些空行？对，也许这个可以离用它的地方更近一点。

482
00:29:58,912 --> 00:29:59,936
好

483
00:30:01,472 --> 00:30:02,496
好，你现在

484
00:30:03,008 --> 00:30:06,848
把声明和调用放一起了。目前还不完美，但是

485
00:30:07,360 --> 00:30:09,408
我们至少做了一些改变。

486
00:30:09,920 --> 00:30:14,272
改的不多。这不是一个完全的重构。这只是让我们更自信。

487
00:30:14,528 --> 00:30:17,344
如果我们想完善心理模型，

488
00:30:17,600 --> 00:30:20,416
并清理一下代码，

489
00:30:20,928 --> 00:30:22,976
这只是第一步。

490
00:30:26,000 --> 00:30:28,304
好，还有什么你想改进的吗？

491
00:30:29,072 --> 00:30:29,584
是的

492
00:30:30,096 --> 00:30:31,888
你看出来还有不爽的地方吗？

493
00:30:32,656 --> 00:30:35,728
是的。这里全是过程代码，一个方法，一屏幕高

494
00:30:36,240 --> 00:30:39,824
做这个，做那个，做这个等等

495
00:30:40,592 --> 00:30:41,616
就是一些脚本

496
00:30:45,968 --> 00:30:50,832
是的。这里"get the train"就没有用了

497
00:30:51,088 --> 00:30:52,624
所以，我们删掉它

498
00:30:53,136 --> 00:30:54,160
好，现在好多了

499
00:30:54,416 --> 00:30:57,488
现在，我们的问题是，

500
00:30:58,256 --> 00:31:04,400
我们共享了"train"，通常这是要返回领域对象，而不是JSON数据

501
00:31:05,936 --> 00:31:07,984
我们看到我们这里有个物理代理

502
00:31:09,264 --> 00:31:15,408
来扩展WebAPI，来组成一个

503
00:31:15,664 --> 00:31:20,784
适配器，通过适配器模式

504
00:31:21,296 --> 00:31:27,440
我们还会继续来着这段代码，所以不用担心你不知道。对比返回

505
00:31:27,696 --> 00:31:30,512
JSON字符串。

506
00:31:30,768 --> 00:31:32,560
我们让它返回Train对象。好的。

507
00:31:33,072 --> 00:31:39,216
这样我们就可以在函数内处理JSON了

508
00:31:39,728 --> 00:31:44,592
这样可以更面向领域，不会和技术细节

509
00:31:44,848 --> 00:31:46,896
纠缠在一起。你觉着呢？同意。你觉着还好？

510
00:31:50,992 --> 00:31:53,040
所以，我发现这个文件

511
00:31:53,296 --> 00:31:55,344
有一个Train的构造函数

512
00:31:55,600 --> 00:32:01,744
Train。好的。我们看到很多反序列化JSON的东西。

513
00:32:02,768 --> 00:32:05,328
这个文件就是这样

514
00:32:05,584 --> 00:32:09,936
这个不要选中吗？

515
00:32:16,080 --> 00:32:17,872
删掉。好的。

516
00:32:19,152 --> 00:32:22,480
这个也没有用到

517
00:32:24,016 --> 00:32:24,528
我们也删除它

518
00:32:25,040 --> 00:32:25,808


519
00:32:26,064 --> 00:32:29,648
这个也变灰了

520
00:32:31,952 --> 00:32:35,280
或者你可以把它分拆到几个文件中.. 嗯，删掉它。

521
00:32:37,584 --> 00:32:38,864
现在，我们在

522
00:32:39,888 --> 00:32:40,656
Train

523
00:32:40,912 --> 00:32:41,680
这个类中

524
00:32:42,192 --> 00:32:47,312
是的。Train没有太多的行为，除了

525
00:32:47,568 --> 00:32:49,872
解析

526
00:32:50,128 --> 00:32:53,200
JSON

527
00:32:53,712 --> 00:32:55,248
神奇的Resharper

528
00:32:55,760 --> 00:32:56,272
好

529
00:32:57,296 --> 00:32:59,856
我们使用Lambda。好的。好。

530
00:33:00,112 --> 00:33:06,256
我要移动这个了。这里有很多..属性...字段...好。

531
00:33:06,512 --> 00:33:12,400
我们有一个构造函数。全是技术细节了。

532
00:33:13,680 --> 00:33:14,704


533
00:33:14,960 --> 00:33:15,984
你还有什么建议吗？

534
00:33:20,592 --> 00:33:21,616
如果我来喝点水

535
00:33:22,128 --> 00:33:23,152
[观众问题]

536
00:33:30,320 --> 00:33:35,696
这里有个更好的地方来解析JSON

537
00:33:35,952 --> 00:33:38,512
Train是领域模型的一部分，所以，我们不应该在这里做这件事。

538
00:33:39,024 --> 00:33:45,168
好吧，让我们来修改。好，我来创建

539
00:33:46,960 --> 00:33:49,264
一个小[方法]来封装我要移动的代码

540
00:33:49,776 --> 00:33:55,920
我们会做很多次的这种操作。抽取，移动。抽取函数，移动到合适的位置。

541
00:33:56,176 --> 00:34:00,784
我们会在会议中多次使用到。好吧，让我们来做第一次。

542
00:34:01,040 --> 00:34:03,088
我想选中我要的所有代码

543
00:34:03,600 --> 00:34:04,624
来抽取，移动

544
00:34:05,392 --> 00:34:06,416
这个可以吗？

545
00:34:06,928 --> 00:34:08,208


546
00:34:09,232 --> 00:34:10,256


547
00:34:10,512 --> 00:34:11,024


548
00:34:11,536 --> 00:34:13,328
再多一点？好的，这个，好的。

549
00:34:14,352 --> 00:34:17,168
代码太长了

550
00:34:20,496 --> 00:34:25,616
好的，我们抽取了函数，但是它现在依然是实体函数。好的。

551
00:34:25,872 --> 00:34:27,408
这个是

552
00:34:27,664 --> 00:34:28,688
Train topology

553
00:34:28,944 --> 00:34:31,248
因为在解析JSON

554
00:34:31,504 --> 00:34:32,016
所以，

555
00:34:32,528 --> 00:34:35,344
对Train的很多属性做了赋值

556
00:34:36,112 --> 00:34:37,904
不错的方法

557
00:34:38,160 --> 00:34:38,672
这个吗？

558
00:34:39,696 --> 00:34:42,256
所以，抽取函数的人

559
00:34:42,768 --> 00:34:43,792
可以把它

560
00:34:44,304 --> 00:34:48,144
移动到新的位置

561
00:34:48,656 --> 00:34:52,496
一个好的查看依赖的方法。因为我想移动它

562
00:34:53,008 --> 00:34:56,080
但是我不想增加依赖

563
00:34:56,336 --> 00:34:58,128
我知道我想隔离

564
00:34:58,384 --> 00:34:58,896
所以

565
00:34:59,152 --> 00:35:00,176
我使用了静态函数

566
00:35:02,992 --> 00:35:04,528
现在出现了几个下划线

567
00:35:05,040 --> 00:35:05,552
几个下划线

568
00:35:05,808 --> 00:35:07,344
这里，这里，因为它们是静态的

569
00:35:07,856 --> 00:35:14,000
现在我们要修改第二个测试，来看看，是否静态... 出现了错误

570
00:35:14,256 --> 00:35:17,584
好的，来看看如何切断这些

571
00:35:17,840 --> 00:35:19,120
好的，联系。

572
00:35:28,790 --> 00:35:38,000
是的，实际上...

573
00:35:38,000 --> 00:35:43,460
[观众问题]

574
00:35:43,460 --> 00:35:49,190
这是一个好主意。我们可以做的更多。如果string不是空，我会增加

575
00:35:49,190 --> 00:35:54,619
reserve seat，而不是现在就改变seat的值

576
00:35:54,619 --> 00:35:59,359
我们或许能够减掉这个行为
每次

577
00:35:59,359 --> 00:36:04,640
调用属性的方法
测试或许是一种方法

578
00:36:04,640 --> 00:36:11,440
你认为呢？让我们来试试吧
我们在这里赋值，而不是让方法改变值

579
00:36:11,440 --> 00:36:19,850
需要一些东西，类似 'seat' ..

580
00:36:19,850 --> 00:36:24,640
哪里？count这里

581
00:36:24,640 --> 00:36:31,150
额，不是~ 像这样一样

582
00:36:31,150 --> 00:36:38,530
Richard你认为你知道Java stream吗？

583
00:36:38,530 --> 00:36:44,940
这种方式更函数式的处理集合和枚举

584
00:36:44,940 --> 00:36:49,780
如果不这样写。下面，我这样来写，取得seat的列表，计算每一个seat

585
00:36:49,780 --> 00:36:54,910
这里lambda是说，每个没有被预定的座位

586
00:36:57,790 --> 00:37:03,610
好的。我很惊讶。
所以你可以处理这些了

587
00:37:03,610 --> 00:37:11,140
它可以在另一个层面完成。或许我可以做类似的关联。

588
00:37:13,840 --> 00:37:18,970
是的。演示一下。

589
00:37:21,040 --> 00:37:32,280
它或许是一个静态函数。我改变了函数签名。

590
00:37:32,280 --> 00:37:41,410
像一组座位。
好的。
然后我改变局部变量，现在我返回seat

591
00:37:47,880 --> 00:37:54,010
所以我们可以抽取函数，所以当需要的时候直接调用

592
00:37:54,010 --> 00:38:00,250
所以，我们适配train topology
这是第一步

593
00:38:00,250 --> 00:38:05,140
因为我们要移动到一个合适的位置

594
00:38:05,140 --> 00:38:12,970
因为。。实际上。。
时间关系

595
00:38:12,970 --> 00:38:19,570
好的。所以，抽取函数，移动到合适的位置

596
00:38:19,570 --> 00:38:27,070
所以，我们可以容易的移动它。
让我们把它放到。。
如果你回到被调用的方法

597
00:38:27,070 --> 00:38:31,859
这里，我们得到一个train

598
00:38:37,150 --> 00:38:42,430
好的。
这里很有趣。
没有使用JSON topology来或得一个train

599
00:38:44,500 --> 00:38:49,799
或许你可以把静态函数放到train data service中

600
00:38:49,799 --> 00:39:03,690
好的，让我们移动它。放到data service中，好吗？

601
00:39:04,270 --> 00:39:08,710
目前为止，我们完成了不错的工作
train中还有依赖，我们一会儿再来改动

602
00:39:08,710 --> 00:39:16,260
所以，我们使它public
是的，并且

603
00:39:16,260 --> 00:39:22,089
目标是改变这个
get train 函数
我来改变函数签名而不是返回task的字符串

604
00:39:25,270 --> 00:39:30,339
好的，修改它。我认为这里请求web api

605
00:39:30,339 --> 00:39:38,020
它有点复杂。但是。。好的。。
你要读懂它，它返回了一个train。

606
00:39:38,020 --> 00:39:42,880
是的。从业务角度，这样更好

607
00:39:42,880 --> 00:39:49,630
我将取得train
好的
你有了新的train，来自topology

608
00:39:49,630 --> 00:39:57,970
但是，train没有使用topology。我们想适配json，所以我们调用它适配train topology

609
00:40:04,529 --> 00:40:12,789
但是，当前train没有接收
你必须要改变它
是的

610
00:40:12,789 --> 00:40:17,079
我必须修改它。
来接收一个seat列表
是的

611
00:40:17,079 --> 00:40:20,319
所以，为了初识化tain，我们会接收一组seat。这样更容易 讨论和接收

612
00:40:20,319 --> 00:40:25,750
是的。删掉它。

613
00:40:25,750 --> 00:40:30,609
所以，我们没有从train到train data service
的引用了

614
00:40:30,609 --> 00:40:38,770
所以它就是一个简单的gettrain了，返回一个train

615
00:40:38,770 --> 00:40:42,579
所以你也不再需要它了

616
00:40:42,579 --> 00:40:47,820
我可以删掉它了
这里我们有一些。。。
好的，是，这样子好多了

617
00:40:47,820 --> 00:40:49,620
我们向train data service请求一个train，我们就获得了一个train

618
00:40:51,240 --> 00:40:55,530
我来编译一下，因为我或许会破坏已有功能。
嗯，这样好多了

619
00:40:55,530 --> 00:41:00,420
还有一些困扰我的
即使它没有编译，也是绿的

620
00:41:00,420 --> 00:41:07,370
是的，我觉着这是一个bug。是的，像是一个bug

621
00:41:07,370 --> 00:41:11,970
我们对train做了个足够多的测试

622
00:41:11,970 --> 00:41:17,220
对于给定的json，给定的topology
这里我们必须做相同的事情

623
00:41:17,220 --> 00:41:24,210
我们不得不调整以前的代码，我们期望。。

624
00:41:24,210 --> 00:41:32,370
签名到新的函数
好的，编译，好了

625
00:41:32,370 --> 00:41:35,130
好的，
不错

626
00:41:35,130 --> 00:41:39,600
你回来了...
让我们返回...
谢谢你，Bruno

627
00:41:39,600 --> 00:41:45,050
好的。
我们实际上移动了train的一部分的topology的代码

628
00:41:45,050 --> 00:41:50,030


629
00:41:50,030 --> 00:41:55,430
现在好多了，这段代码看起来舒服多了。但是还是有很多的问题

630
00:41:57,290 --> 00:42:03,800
例如，我们来看看train。
好的。我们做了一些清洁，改变了一些。

631
00:42:03,800 --> 00:42:13,880
但是，这个train是一个纯的数据类，没有任何责任

632
00:42:13,880 --> 00:42:18,650
我不确定，曾经有个朋友说过，

633
00:42:18,650 --> 00:42:23,180
这是对象是年轻人对象，无论如何也要承担一些责任

634
00:42:25,970 --> 00:42:33,650
是的。让我们来吧

635
00:42:33,650 --> 00:42:39,710
我们有seat的概念。

636
00:42:39,710 --> 00:42:45,860
这是一个领域名字，

637
00:42:45,860 --> 00:42:57,620
你知道我们的领域的应该包含什么

638
00:42:59,360 --> 00:43:03,950
所以，我们在代码里缺少所有的领域概念

639
00:43:06,800 --> 00:43:12,470
但是，我们有数据类

640
00:43:18,200 --> 00:43:22,010
和一堆行为，我建议来包装这些行为

641
00:43:22,010 --> 00:43:29,300
把他们放到合适的位置，打破这些年轻对象

642
00:43:29,300 --> 00:43:37,310
或许可以参考幻灯片，让我们一起直观的看看
我们有A，B类

643
00:43:40,970 --> 00:43:44,990
A对应web ticket manager类，B是train

644
00:43:44,990 --> 00:43:50,300
所以，看看我们要做什么。我们抽取行为

645
00:43:50,300 --> 00:43:54,200
移动到相同的类里，

646
00:43:56,870 --> 00:44:01,310
然后在移动到合适的位置
比如train，在今天结束时，

647
00:44:01,310 --> 00:44:06,560
我们要做的更多。
很好的平衡

648
00:44:06,560 --> 00:44:14,030
是的。领域的很多东西
是的
让我们返回代码

649
00:44:14,030 --> 00:44:22,970
所以，我建议来做一下
好的。每个火车保留作为是第一业务规则。

650
00:44:25,490 --> 00:44:30,370
火车不应该超过它的最大承载能力。我建议抽取一个方法

651
00:44:30,370 --> 00:44:41,600
但是，或许。
它没有超过火车的总能力

652
00:44:41,600 --> 00:44:45,260
一旦。。。这里。。。

653
00:44:45,260 --> 00:44:53,450
是的。capacity
抱歉，我抽取了一个非静态方法。
可以方便的移动

654
00:44:57,380 --> 00:45:07,580
这个方法。。我们应该根据。。移动它。
train

655
00:45:07,580 --> 00:45:13,730
是的。这里有个提示。Resharper的F6可以移动

656
00:45:13,730 --> 00:45:18,680
你可以传递train而不是参数，这样你就方便的移动到了train中

657
00:45:18,680 --> 00:45:23,780
好的。我们有了train。当我请求座位的时候，不会超过承载能力

658
00:45:23,780 --> 00:45:33,950
好的。这里我们可以建设一个可用seat列表

659
00:45:36,770 --> 00:45:43,280
所以我们可以找到可用的seat

660
00:46:02,260 --> 00:46:06,569
实际上，我们这里可以介绍一些概念。
你认为呢？

661
00:46:08,790 --> 00:46:22,530
[观众问题]

662
00:46:23,119 --> 00:46:28,440
是的。今天结束的时候，我们需要所有的座位在同一节车厢中

663
00:46:28,440 --> 00:46:33,500
但是，在这之前领域专家说了很多reservation attempt

664
00:46:33,500 --> 00:46:40,050
这对他是一个很重要的概念。所以，我建议可以引入这个部分，来代替available seats

665
00:46:40,050 --> 00:46:43,950


666
00:46:50,690 --> 00:46:57,480
在我们改进代码之前，Rruno要show一些东西

667
00:46:57,480 --> 00:47:04,319
或许你们有的人已经知道了

668
00:47:04,319 --> 00:47:10,589
这是一个检查依赖的工具 JArchitect

669
00:47:10,589 --> 00:47:18,569
可以用在java或者c++，是一个很高级的工具。
它可以分析代码

670
00:47:18,569 --> 00:47:25,170
可以报warning或者error。我们一直和Macau深度合作

671
00:47:25,170 --> 00:47:31,170
是的，我们要求他介绍一个新的检查代码的方法

672
00:47:31,170 --> 00:47:35,010
使用统一语言, 现在还在原型阶段

673
00:47:35,010 --> 00:47:41,069
没有发布，我们想象你有一个团队。你有遗留代码，你有知道领域专家的词典

674
00:47:45,060 --> 00:47:50,520
并且创建了规则，它依赖统一语言调用你的代码

675
00:47:50,520 --> 00:47:56,700
你可以看到我们有一些问题

676
00:47:56,700 --> 00:48:03,240
这些单词没有很好的一致。

677
00:48:03,240 --> 00:48:10,530
我们创建了一组单词作为我们的领域

678
00:48:10,530 --> 00:48:16,920
像train等等，当前我们定义了你想要的每个领域

679
00:48:16,920 --> 00:48:23,430
我们要检查的工具，它仍然在alpha阶段

680
00:48:27,059 --> 00:48:32,729
但是我认为这会非常有趣，当它成熟后。能够有一些代码的味道检查

681
00:48:35,249 --> 00:48:43,949
好的，好的
 运行一下
结果如何？

682
00:48:43,949 --> 00:48:52,619
让我们回到业务。

683
00:48:52,619 --> 00:48:58,079
我们有一组 available seats，我建议我们改变签名

684
00:48:58,079 --> 00:49:02,699
我们引入reservation attempt的概念。所以不再返回一组seats，

685
00:49:02,699 --> 00:49:13,349
我们来返回reservation attempt，哦，写错了。

686
00:49:13,349 --> 00:49:15,949
谢谢你

687
00:49:16,730 --> 00:49:24,170
好的，类型不存在。是的，我知道我可能会重命名它

688
00:49:24,170 --> 00:49:37,730
抱歉

689
00:49:37,730 --> 00:49:41,240
reservation attempt不存在，让我们创建它。好吗？

690
00:49:43,670 --> 00:49:54,049
这里，这个函数返回reservation attempt

691
00:49:54,049 --> 00:49:59,079
我要做的就是在这里创建它，在最后

692
00:49:59,079 --> 00:50:05,510
返回一个reservation attempt,
好吗？
给它提供刚刚找到的一组seat

693
00:50:05,510 --> 00:50:11,270
我要做的就是创建一个构造函数，接受一组seat

694
00:50:14,569 --> 00:50:23,690
好的，这就是我想要的。
或许我需要遍历seats

695
00:50:23,690 --> 00:50:29,809
让我从创建一个seat属性[参数]开始

696
00:50:29,809 --> 00:50:36,410
或许创建一个只读属性，

697
00:50:39,170 --> 00:50:44,869
因为我需要遍历reservation attempt的seats
好吗？

698
00:50:44,869 --> 00:50:49,819
所以，我创建了一个 reservation attemp ，它有个 seats 的属性。就这样。

699
00:50:49,819 --> 00:50:55,730
很好。所以 findavailableseats 现在，名字
改为 build reservation temp 更好

700
00:50:55,730 --> 00:51:02,990
是的。
所以现在方法创建reservation attempt，根据找到的可用座位

701
00:51:05,150 --> 00:51:08,450
返回 reservation attemp
大家觉着如何？

702
00:51:12,410 --> 00:51:17,569
现在代码已经不能编译了，因为我一直使用seats列表

703
00:51:17,569 --> 00:51:23,210
现在已经变成了reservation attempt。

704
00:51:23,210 --> 00:51:28,820
然后加入到seats中，

705
00:51:28,820 --> 00:51:33,320
让我来填充这三个地方

706
00:51:33,320 --> 00:51:46,040
f12
oops
得到 seats

707
00:51:46,040 --> 00:51:51,260
应该可以编译了，检查一下
是的，可以了，绿了

708
00:51:51,260 --> 00:51:58,910
所以，这里我直接创建了一个概念，它来自于领域专家 reservation attempt，来代替一组seats

709
00:52:02,300 --> 00:52:07,520
可以吗 ?
reservation attempt可以做什么呢？

710
00:52:07,520 --> 00:52:14,000
这里，

711
00:52:14,000 --> 00:52:18,770
像是说reservation attempt满了吗？

712
00:52:18,770 --> 00:52:24,560
领域专家谈论了很多，让我们来为它创建一个方法。抽取，移动

713
00:52:24,560 --> 00:52:31,640
满了还是没满

714
00:52:31,640 --> 00:52:37,040
我觉着不错了
所以我们来问reservation attempt你满了吗？

715
00:52:37,040 --> 00:52:44,510
所以，第一步抽取，先放在当前类中，然后移动

716
00:52:44,510 --> 00:52:47,530
抱歉

717
00:52:47,530 --> 00:52:51,590
我抽取了行为，然后把它放到合适位置，就是revervation attempt

718
00:52:51,590 --> 00:52:56,630
还有一些东西困扰我，你把seat request count传递了两次

719
00:52:56,630 --> 00:53:01,400
是的，这里传了，这里传了

720
00:53:01,400 --> 00:53:06,320
实际上你可以在构造reservation attempt的时候传递 seat request count，这样只需要一次

721
00:53:06,320 --> 00:53:10,250
我们就不需要每次检查是否满了的时候，都传递给它

722
00:53:10,250 --> 00:53:16,810
我同意，做吧
我们到实现

723
00:53:16,810 --> 00:53:21,110
我在reservation attempt 的构造函数中提供了seats request count

724
00:53:21,110 --> 00:53:31,000
好的，抱歉，
我好想犯了个错误

725
00:53:32,100 --> 00:53:38,970
好的。我改变了revervation attempt 的构造函数。我倾向于给构造函数加一个参数

726
00:53:38,970 --> 00:53:44,520
是的，让我们来做一下。
把 seats requested count 放到这里

727
00:53:44,520 --> 00:53:49,290
我简单创建一个只读的属性，它不是public的。

728
00:53:49,290 --> 00:53:53,580
所以，类外不能访问

729
00:53:53,580 --> 00:53:59,610
好的，我有它了。
怎么来使用呢

730
00:53:59,610 --> 00:54:06,080
没有fullField都可以用它来代替了

731
00:54:06,080 --> 00:54:14,670
我们可以放心的删掉参数了

732
00:54:14,670 --> 00:54:22,140
因为使用c#，我可以转换成属性表达式

733
00:54:22,140 --> 00:54:31,470
好的，让我们移动它，好的，不错

734
00:54:31,470 --> 00:54:38,070
让我们返回每个fullfield。
看到了吗？在reserve函数中

735
00:54:38,070 --> 00:54:43,620
我请求给train建造一个reservation attempt。
哦，你没有移动BuildReservation

736
00:54:44,070 --> 00:54:49,110
下面，我把build attemp移动到train中

737
00:54:49,110 --> 00:54:54,150
首先，让我们来移动它，移动到train中，然后请求train

738
00:54:54,150 --> 00:54:57,750
Train, 请根据请求的座位数建造 reservation attempt

739
00:54:57,750 --> 00:55:02,940
得到了一个 reservation attempt
然后问它是不是满足，如果满足

740
00:55:02,940 --> 00:55:07,620
我会继续请求bookingReference，bookingRef 不是这个领域的

741
00:55:07,620 --> 00:55:13,800
让我们放到领域边界中

742
00:55:13,800 --> 00:55:20,580
我们迭代reservation attempt 中的每个seat

743
00:55:22,170 --> 00:55:28,320
赋值bookingRef。
好的，或许我们可以抽取函数，然后放到reservation attempt 中

744
00:55:28,320 --> 00:55:34,010
在这里赋值bookingRefs

745
00:55:34,010 --> 00:55:40,040
这是一个抽取的例子

746
00:55:40,420 --> 00:55:44,839
我们赋值bookingRefs

747
00:55:44,839 --> 00:55:48,619
好的，我来抽取

748
00:55:48,619 --> 00:55:54,200
这个方法是下一个链，需要被移动

749
00:55:57,619 --> 00:56:02,930
移动bookingRef到reservation attempt中
好的，让我们来看实现

750
00:56:05,210 --> 00:56:09,650
我们获取了bookingRefs，然后赋值给了每一个seat

751
00:56:09,650 --> 00:56:21,020
可以吗?
[观众问题]
我一直在想跟你一样的问题

752
00:56:21,020 --> 00:56:28,010
领域专家确实一直在说，这个过程就是创建一个reservation attempt

753
00:56:28,010 --> 00:56:32,270
今天结束的时候，我们会把它放到reservation attemp中。我有相同的想法

754
00:56:35,670 --> 00:56:40,400
是的。没错

755
00:56:40,400 --> 00:56:47,450
好问题。
实际上，我们常常以为这是要给技术问题

756
00:56:50,390 --> 00:56:55,730
，但是它常常也是领域专家的一个概念。
所以，我们有train caching，用来保存

757
00:56:55,730 --> 00:57:02,000
Wow，好的
或许是时候在程序中建立缓存了

758
00:57:02,000 --> 00:57:08,119
所以你可以缓存东西。
让我们看看是不是相关

759
00:57:08,119 --> 00:57:12,529
relevant here
可以吗?
我们在 web ticket manager 中有个缓存

760
00:57:12,529 --> 00:57:16,970
然后关联到 web ticket manager 的构造函数中

761
00:57:16,970 --> 00:57:23,930
然后清除它，很有意思，我们清除了它。

762
00:57:23,930 --> 00:57:30,710
这里说明它用了三秒，平均两秒来清除缓存

763
00:57:30,710 --> 00:57:37,099
我不知道这是什么。但是我期望它是这样的。然后我们保存。

764
00:57:37,099 --> 00:57:43,700
是的， bookingReference ， 和train id,  都保存到cache中。
就这样

765
00:57:48,470 --> 00:57:55,880
所以，缓存只是保存东西。

766
00:57:55,880 --> 00:58:02,570
或许可以思考一下
或许是一个没有完成的东西

767
00:58:02,570 --> 00:58:05,720
或许实现了有错误

768
00:58:07,849 --> 00:58:16,609
为什么要缓存topology，这是不错的。它可能被修改

769
00:58:19,250 --> 00:58:25,400
看起来是一些无用的东西，让我们清除掉

770
00:58:25,400 --> 00:58:33,910
我可以移除掉了，移除掉吧。
我感觉好多了
[观众问题]

771
00:58:47,720 --> 00:58:53,000
这是一个我们可以讨论的话题，因为它[领域专家]不在这里

772
00:58:53,000 --> 00:58:56,210
我们以前联系过他，因为这不是第一举行这个会议了

773
00:58:56,210 --> 00:59:01,250
是的，我同意你的观点。有一些东西必须要讨论

774
00:59:01,250 --> 00:59:06,200
不需要讨论技术细节，但是可以记起我们当时的讨论

775
00:59:06,200 --> 00:59:18,170
[Audience Question]
是的，对

776
00:59:18,170 --> 00:59:26,410
我们返回得到train的方法，train data service

777
00:59:26,410 --> 00:59:31,880
然后判断train 的 capacity

778
00:59:31,880 --> 00:59:36,290
我们创建了一个reservation attempt。我们检查它是否满了

779
00:59:36,290 --> 00:59:42,770
检查它是否满了，因为可能没有座位

780
00:59:42,770 --> 00:59:50,000
然后请求bookingReference服务

781
00:59:50,000 --> 00:59:54,200
我们把booking reference赋值给预定的seat上

782
00:59:54,200 --> 01:00:00,670
return the the result I don't know for
you but now the method is one screen high

783
01:00:00,670 --> 01:00:05,480
we are embracing a little bit more the
concept of the domain

784
01:00:06,531 --> 01:00:12,163
After the spreading the news goes into the popular location the Twin Towers Malaysia

785
01:00:12,419 --> 01:00:13,187
The

786
01:00:13,443 --> 01:00:14,979
The seats also

787
01:00:15,235 --> 01:00:17,539
The resolution attempt also

788
01:00:19,331 --> 01:00:22,659
Yes I return money

789
01:00:23,171 --> 01:00:26,755
No what would you suggest because it's important to be time boxed

790
01:00:27,011 --> 01:00:29,827
Haha because I mean you can improve god a lot

791
01:00:30,083 --> 01:00:31,619
What time we have an objective

792
01:00:32,131 --> 01:00:33,411
Celebrity brewers

793
01:00:33,667 --> 01:00:37,507
How to fix a bag

794
01:00:37,763 --> 01:00:38,531
Concept

795
01:00:40,835 --> 01:00:42,115
Return Tesco

796
01:00:43,651 --> 01:00:49,283
Yep absolutely no idea what you're saying that in you what weekend is to get rid of that synergies on here

797
01:00:49,795 --> 01:00:53,379
Any set to return to Amazon

798
01:00:53,891 --> 01:00:55,171
And then return

799
01:00:55,427 --> 01:00:59,523
Itasca because I was on here so that December 3rd is purely Dublin

800
01:01:00,035 --> 01:01:05,155
No strangers on inside a simply recharging the oven in stock

801
01:01:05,411 --> 01:01:06,179
Will do that

802
01:01:06,439 --> 01:01:07,975
好的，我们接下来要那样做了

803
01:01:08,231 --> 01:01:12,839
但在这之前，我们希望介绍几个之前没讲过的概念

804
01:01:13,351 --> 01:01:14,375
因为

805
01:01:15,143 --> 01:01:16,679
当我们进入"BuildReservationAttempt"这里

806
01:01:18,727 --> 01:01:20,775
我们 build 是基于

807
01:01:21,287 --> 01:01:25,383
 Train 这个层面，而不是 Coach 这个层面

808
01:01:25,639 --> 01:01:28,455
我们直接调用了所有的 seats

809
01:01:28,967 --> 01:01:33,575
所以怎样理解这里的 coach 的概念呢？你的想法是什么？

810
01:01:53,799 --> 01:01:59,943
基本上，元数据中每个座位的名字就像 a1，a2，a3，b4组成

811
01:02:00,199 --> 01:02:04,551
a 是每个 coach 的名字

812
01:02:04,807 --> 01:02:06,599
这样我才能隐式的找出 seat 与所属 coach

813
01:02:11,719 --> 01:02:13,767
是的，没错。这是个好主意

814
01:02:14,791 --> 01:02:17,351
但我们要怎么介入它呢？

815
01:02:17,607 --> 01:02:18,119
就现在

816
01:02:18,631 --> 01:02:20,679
下一步该怎么做？

817
01:02:24,263 --> 01:02:29,127
是的，没错。如果现在键盘在你手里的话

818
01:02:29,383 --> 01:02:30,919
要如何根据你建议的开始呢？

819
01:02:38,343 --> 01:02:39,111
没错

820
01:02:41,415 --> 01:02:43,719
当然可以。但我们得从一个小的测试开始着手

821
01:02:43,975 --> 01:02:47,303
从 train 那里我们能获得....

822
01:02:47,559 --> 01:02:50,119
例如，我们会校验 train 中暴露出的 coaches

823
01:02:50,375 --> 01:02:52,935
例如

824
01:02:53,959 --> 01:02:56,519
因为我们都热衷于

825
01:02:57,031 --> 01:02:57,799
TDD

826
01:02:58,567 --> 01:02:59,591
而且

827
01:02:59,847 --> 01:03:01,383
我们想要...

828
01:03:01,639 --> 01:03:05,479
去创建...所以让我们来增加一个 TreeShould 类...should...fixture...

829
01:03:05,735 --> 01:03:08,807
到目前为止我们只有一些 architecture 测试

830
01:03:09,575 --> 01:03:11,879
那完全是系统行为

831
01:03:12,135 --> 01:03:13,927
.....所以我们目前有三个测试

832
01:03:14,183 --> 01:03:19,047
到了这里，我要说得是，这是我们的第一个单元测试

833
01:03:20,071 --> 01:03:21,607
是时候去...

834
01:03:21,863 --> 01:03:24,935
也许...Train 应该暴露出 coaches...之类的东西...

835
01:03:26,471 --> 01:03:27,495
所以我们在这里拿到了 Train

836
01:03:28,519 --> 01:03:30,823
所以 TrainShould 这里应该暴露出 coaches?

837
01:03:38,503 --> 01:03:40,551
我得移动到它上面去不然没法...

838
01:03:44,135 --> 01:03:45,415
应该是...expose_coaches

839
01:03:46,695 --> 01:03:47,207
应该是...expose_coaches

840
01:03:48,231 --> 01:03:48,743
Okay..

841
01:03:53,095 --> 01:03:59,239
对...没错....完全跟那个有关

842
01:03:59,495 --> 01:04:03,335
实际上，我脑海中有一些 coach 的新业务规则....even he first to fix by then

843
01:04:03,847 --> 01:04:04,359
但是

844
01:04:04,871 --> 01:04:06,407
由于资金的原因

845
01:04:06,663 --> 01:04:12,807
在他脑海中有了一些东西来支撑他的新业务规则

846
01:04:13,063 --> 01:04:13,575
例如

847
01:04:13,831 --> 01:04:14,855
我们不应该

848
01:04:15,367 --> 01:04:19,463
养活多于40%的 Coache

849
01:04:19,975 --> 01:04:20,487
打个比方

850
01:04:20,743 --> 01:04:25,351
and step like so it we need the population through to make it

851
01:04:36,871 --> 01:04:38,151
我们需要，到目前为止

852
01:04:38,407 --> 01:04:41,735
我们需要在 Coach 上做些操作

853
01:04:41,991 --> 01:04:44,295
我们需要那个

854
01:04:44,551 --> 01:04:45,319
回答是肯定的

855
01:04:45,575 --> 01:04:51,719
如果你想封装它全部的实现细节以此保证私有性

856
01:04:51,975 --> 01:04:52,487
就不要那么写

857
01:04:52,999 --> 01:04:55,047
好了

858
01:04:55,559 --> 01:04:57,607
我要在这做一些解释因为我使用了

859
01:04:58,631 --> 01:05:00,423
snake name

860
01:05:00,679 --> 01:05:02,727
因为

861
01:05:02,983 --> 01:05:09,127
我们用他来mock 测试场景中的一些情况，这是一个有着10个元素的topology table

862
01:05:09,383 --> 01:05:15,527
所以他将会构建一个....这是一种验证 topology 的方式

863
01:05:15,783 --> 01:05:21,415
而且很合适因为我知道这个这个 topology table 中

864
01:05:21,671 --> 01:05:23,719
有两个 coach

865
01:05:24,487 --> 01:05:25,767
我们尝试给每个 coach 预定座位 所以这也是为什么用它的原因

866
01:05:26,023 --> 01:05:29,351
所以在你的测试中现在关联到了 Train

867
01:05:29,863 --> 01:05:32,423
Ok 在 Train 中提供了....

868
01:05:32,935 --> 01:05:35,239
一个由 AdaptedTrainTopology 提供的 seat 的集合

869
01:05:36,263 --> 01:05:36,775
topology

870
01:05:37,031 --> 01:05:37,543
是的

871
01:05:38,311 --> 01:05:39,335
所以我们应该 check

872
01:05:40,359 --> 01:05:42,151
train...coaches...

873
01:05:42,919 --> 01:05:43,687
抱歉

874
01:05:45,991 --> 01:05:46,503
而且

875
01:05:47,015 --> 01:05:49,575
我不喜欢 Coach 这个类因为现在它还不存在

876
01:05:51,623 --> 01:05:52,903
我们得 check

877
01:05:54,695 --> 01:05:55,719
长度为2

878
01:05:56,231 --> 01:05:59,047
的集合...因为在 train topology 中有两个 coache

879
01:06:01,863 --> 01:06:05,703
也许你还需要 check 每个 coach 有10个座位

880
01:06:07,495 --> 01:06:13,639
这很长当我认为应该是个 Dictionary，例如 coaches["A"], coaches["B"]

881
01:06:15,431 --> 01:06:16,199
Coaches["A"]

882
01:06:16,967 --> 01:06:19,015
the seats...点 seats

883
01:06:19,271 --> 01:06:21,319
长度为10

884
01:06:21,575 --> 01:06:23,623
因为每个 coach 都...

885
01:06:23,879 --> 01:06:25,927
Ok

886
01:06:26,439 --> 01:06:31,047
现在直接把 Train 中的暴露出去吧

887
01:06:31,303 --> 01:06:33,607
好，我们现在开始生成一些代码

888
01:06:34,887 --> 01:06:35,399
 ok

889
01:06:37,191 --> 01:06:38,983
这里...你刚提到的 Dictionary

890
01:06:41,799 --> 01:06:42,567
Name

891
01:06:45,639 --> 01:06:46,407
Coach

892
01:06:47,687 --> 01:06:48,711
目前还不存在的

893
01:06:48,967 --> 01:06:51,527
同样的，你也要创建

894
01:06:51,783 --> 01:06:52,295


895
01:06:52,551 --> 01:06:55,111
Coach 类...没错，我到时候会创建它的...

896
01:06:57,415 --> 01:07:00,231
所以现在 Train 有了

897
01:07:00,743 --> 01:07:02,279
一个 coach 集合

898
01:07:02,791 --> 01:07:04,071
所以我现在可以..

899
01:07:04,327 --> 01:07:06,119
从 Dictionary 入手

900
01:07:08,679 --> 01:07:14,823
如果我们有足够的时间，我们不仅要作为 Dictionary 暴露出去，还要把它变为只读的

901
01:07:15,079 --> 01:07:17,383
或者其他什么好的概念

902
01:07:18,407 --> 01:07:20,199
代理类之类的...

903
01:07:20,455 --> 01:07:24,295
但因为我们想要展示出更多其他的东西在这

904
01:07:25,063 --> 01:07:27,111
所以....

905
01:07:27,367 --> 01:07:28,903
循环遍历Seats

906
01:07:29,159 --> 01:07:32,487
So here we dig into the concept D I G would be

907
01:07:32,743 --> 01:07:37,863
Ok，我现在拿到了一个 seats 的集合

908
01:07:38,375 --> 01:07:41,191
每个 seat 上都隐式的含有 coach 的名字

909
01:07:41,959 --> 01:07:45,543
所以我只需要 check 每个作为上是不是已经安排了教练

910
01:07:45,799 --> 01:07:46,567
通过他们的名字

911
01:07:47,079 --> 01:07:49,639
因为座位上含有 coach 的名字

912
01:07:50,151 --> 01:07:53,735
如果 Coach 不在这个 Dictionary 中

913
01:07:54,503 --> 01:07:55,783
我们就把他

914
01:07:56,039 --> 01:07:56,551
添加进去

915
01:07:57,063 --> 01:07:57,831
添加到 dictionary 中

916
01:08:00,903 --> 01:08:01,415
抱歉？

917
01:08:05,511 --> 01:08:11,655
是的，我们可以用 link...对...在最开始的逻辑中我们查询了 seats，I prefer to show without thinking

918
01:08:13,447 --> 01:08:14,215
而且

919
01:08:14,471 --> 01:08:20,359
通过实例化一个新的 Coach...然后提供给他名字...

920
01:08:23,687 --> 01:08:24,199
Ok

921
01:08:24,711 --> 01:08:30,855
我们轮询了Train 中的每个 seat

922
01:08:31,111 --> 01:08:35,975
我们将相关的 coach 也添加进了 Dictionary

923
01:08:36,487 --> 01:08:37,767
之后我们不得不

924
01:08:38,023 --> 01:08:38,791
添加 seat（给每个 coach）

925
01:08:41,863 --> 01:08:42,887
coach 名称

926
01:08:47,239 --> 01:08:50,823
第一步第二步都是将 seat 添加进 coach

927
01:08:54,407 --> 01:08:55,175
So...coaches...

928
01:08:55,687 --> 01:08:57,735
...coaches...数组...seat

929
01:08:57,991 --> 01:08:58,759
seat 点 coach name

930
01:08:59,783 --> 01:09:00,807


931
01:09:01,063 --> 01:09:02,087
I introduced available

932
01:09:03,879 --> 01:09:05,159
我们叫他 newCoach？

933
01:09:08,743 --> 01:09:09,255
可以

934
01:09:09,767 --> 01:09:10,791
没问题

935
01:09:13,863 --> 01:09:14,631
newCoach

936
01:10:15,399 --> 01:10:15,911
add...seat...

937
01:09:18,983 --> 01:09:25,127
哦，你做这个是为了使用 lambda 表达式？你可以先让它工作然后我们再来重构

938
01:09:26,151 --> 01:09:28,711
没问题....当然可以...

939
01:09:34,087 --> 01:09:35,367
现在....

940
01:09:36,647 --> 01:09:39,463
Ok. Ok

941
01:09:39,719 --> 01:09:41,511
实际上你不得不 ......我得先重命名它

942
01:09:41,767 --> 01:09:47,911
coache 已经在这了

943
01:09:48,167 --> 01:09:50,727
coach..coach....coach...and on that coach..你已经设置过 seats 了

944
01:09:51,239 --> 01:09:51,751
So...ok

945
01:09:54,311 --> 01:09:55,847
接下来我要...

946
01:09:56,871 --> 01:09:58,919
假设这里我已经有seats这个 list 了

947
01:10:01,479 --> 01:10:01,991
So you are

948
01:10:02,503 --> 01:10:07,367
What glue do you use to make USB data switch for handling unit

949
01:10:07,623 --> 01:10:08,391
we will need to make a coach

950
01:10:09,671 --> 01:10:15,815
A nice place to to find our list of seats I would say

951
01:10:17,607 --> 01:10:18,119
但是

952
01:10:18,375 --> 01:10:19,143
这里

953
01:10:19,399 --> 01:10:21,959
有些东西让我有点烦...但

954
01:10:22,471 --> 01:10:23,239
你先完成吧

955
01:10:23,495 --> 01:10:25,799
我想看到它变绿....

956
01:10:27,591 --> 01:10:28,871
变绿...

957
01:10:33,991 --> 01:10:37,063
ok，他们都变绿了

958
01:10:39,623 --> 01:10:42,439
哦不不不，我不认为它编译通过了

959
01:10:43,463 --> 01:10:44,231
就像这些一样

960
01:10:44,999 --> 01:10:51,143
Oh, yeah...暴露出的 seats 的大小....topology....封装...还有...

961
01:10:54,471 --> 01:10:55,239
seats

962
01:10:55,495 --> 01:10:56,775
现在应该变绿了

963
01:11:02,407 --> 01:11:04,711
OK, 我并不是特别喜欢这种...

964
01:11:05,223 --> 01:11:05,735
我们

965
01:11:06,247 --> 01:11:09,575
添加了一个 seat 给 coach...我们改变了他

966
01:11:09,831 --> 01:11:10,855
但实际上

967
01:11:11,111 --> 01:11:12,391
如果你有足够的时间

968
01:11:12,903 --> 01:11:14,439
这里还有一些事情应该去做

969
01:11:15,975 --> 01:11:19,303
那就是让所有事情变得 immutable

970
01:11:20,327 --> 01:11:22,119
因为我们所做的事其实...

971
01:11:22,375 --> 01:11:27,495
基于当你想要预定...我们想要预定一些座位，我们拿到了 train apology

972
01:11:27,751 --> 01:11:29,799
但我们并不是他的所有者

973
01:11:30,055 --> 01:11:31,591
这是从外部来的数据

974
01:11:32,103 --> 01:11:32,871
我们只是在他上面工作

975
01:11:34,151 --> 01:11:39,015
而且我并不希望我们冒某种危险去和它保持关联

976
01:11:39,783 --> 01:11:40,807
因为这很愚蠢

977
01:11:41,575 --> 01:11:47,719
而且事实是当我拿到了 train apology，它应该是不变的，我能做的只有在他上面

978
01:11:48,743 --> 01:11:51,559
去查询某些信息， 或者去创建一个reservation attempt

979
01:11:51,815 --> 01:11:54,119
但我并不希望我的同事

980
01:11:54,375 --> 01:11:57,703
或者新加入这个 team 的人

981
01:11:57,959 --> 01:12:02,567
to...to...break that by introducing a cache and a state well

982
01:12:02,823 --> 01:12:03,591
我不想这样

983
01:12:04,615 --> 01:12:10,759
所以如果有时间我会让所有事情变得 immutable，train，coach都是这样

984
01:12:11,015 --> 01:12:12,551
seats 也是

985
01:12:12,807 --> 01:12:14,599
只有

986
01:12:14,855 --> 01:12:17,671
一件事是 mutable 的，那就是 reservation attempt

987
01:12:18,951 --> 01:12:24,071
之前的 reservation attempt 是一个有生命周期的实体

988
01:12:24,327 --> 01:12:27,911
但是随着时间变化

989
01:12:28,167 --> 01:12:31,751
最后我会将 reservation attemp 演变成 reservation

990
01:12:32,007 --> 01:12:33,799
而且reseravation 也是 immutable 的

991
01:12:34,055 --> 01:12:36,871
从 reservation attemp 到 reservation

992
01:12:37,127 --> 01:12:38,663
ok，有问题吗？

993
01:12:46,599 --> 01:12:52,743
抱歉? 是的...是的...当然....这也是个理由

994
01:12:52,999 --> 01:12:54,279
如果我们回到

995
01:12:54,535 --> 01:12:55,815
addseats

996
01:12:56,327 --> 01:13:00,935
我们想对 seats 做的是一个叫做 closure of operation 的事情

997
01:13:01,191 --> 01:13:02,727
这意味着一个coach

998
01:13:02,983 --> 01:13:06,567
将会有一个 addSeats 方法，所以我可以添加 seats 给 coach

999
01:13:06,823 --> 01:13:10,151
But instead of mutating me the coache instance

1000
01:13:10,407 --> 01:13:13,223
What we would like is to for that guy to reach on me

1001
01:13:13,735 --> 01:13:15,015
The New Coach

1002
01:13:15,271 --> 01:13:16,551
a new sort of coach installs

1003
01:13:16,807 --> 01:13:17,319
所以

1004
01:13:17,575 --> 01:13:20,903
我调用了一个 coach 实例上的 addSeats 方法

1005
01:13:21,415 --> 01:13:24,743
它将返回给我一个包含了 seat 的

1006
01:13:24,999 --> 01:13:26,535
新的 coach 对象

1007
01:13:26,791 --> 01:13:32,679
但不改变前一个实例

1008
01:13:32,935 --> 01:13:33,447
听着

1009
01:13:33,959 --> 01:13:34,983
所以

1010
01:13:35,239 --> 01:13:39,847
好的地方是热情但是可以解耦

1011
01:13:40,103 --> 01:13:43,175
简单的移动代码

1012
01:13:43,431 --> 01:13:44,711
这里的 coach

1013
01:13:45,223 --> 01:13:46,503
 代表他自己

1014
01:13:46,759 --> 01:13:50,855
你知道的....coach 的方法意味着你拥有了 coach 的源

1015
01:13:51,367 --> 01:13:57,511
这样，如果我想要移动它比之前 coach 中关联一个新的类型那种方式要简单的多

1016
01:13:57,767 --> 01:13:59,047
就像这样

1017
01:13:59,559 --> 01:14:01,095
Ok

1018
01:14:01,607 --> 01:14:02,375
Ok yeah

1019
01:14:17,223 --> 01:14:23,367
 在任何情况下与领域专家交流都是一件重要的事

1020
01:14:23,623 --> 01:14:25,671
不幸的是，我们之前在做这个 session 时都会有个领域专家

1021
01:14:25,927 --> 01:14:26,951
就在我们旁边

1022
01:14:27,207 --> 01:14:28,999
然后我们问很多问题记下来很多东西

1023
01:14:29,255 --> 01:14:31,303
所以你脑海里有很多隐式的..你知道的...在你脑海里

1024
01:14:31,559 --> 01:14:35,143
是的，没错，你们应该有这种讨论

1025
01:14:35,399 --> 01:14:36,935
但是

1026
01:14:37,703 --> 01:14:43,847
我想说的是这里有很多实现细节

1027
01:14:44,103 --> 01:14:46,919
这是对所有人的，我不想讨论对于

1028
01:14:47,175 --> 01:14:50,503
我不是 owner 的和跟状态有关的东西

1029
01:14:52,551 --> 01:14:53,319
我不是

1030
01:14:53,575 --> 01:14:55,879
train topology 的所有者，我只是一个用户

1031
01:14:56,135 --> 01:14:59,463
每次一个请求返回给我，

1032
01:14:59,975 --> 01:15:02,023
拿到一份快照

1033
01:15:02,535 --> 01:15:05,607
通过我的的领域模型，然后去做一个 reservation

1034
01:15:07,399 --> 01:15:07,911
所以

1035
01:15:21,223 --> 01:15:26,599
是的，当然

1036
01:15:27,623 --> 01:15:33,767
Ok,我认为这没有 pop up....是的...当然...取而代之的是改变 coach

1037
01:15:34,023 --> 01:15:36,327
然后转换到一个新的 coach 的实例上去吧

1038
01:15:36,583 --> 01:15:39,143
让它在这里返回一个 coach

1039
01:15:40,679 --> 01:15:46,055
所以我并没有说这意味着改变已有的 coach

1040
01:15:46,311 --> 01:15:47,079
一个新的 coach 实例

1041
01:15:49,895 --> 01:15:50,407
Coach

1042
01:15:50,663 --> 01:15:51,687
Ok

1043
01:15:51,943 --> 01:15:52,711
和 seat 的名称...

1044
01:15:55,015 --> 01:15:55,783
还有什么？

1045
01:15:56,295 --> 01:15:57,063
一个集合？

1046
01:15:57,319 --> 01:15:57,831
一个新的集合？

1047
01:15:59,879 --> 01:16:00,647
是的

1048
01:16:00,903 --> 01:16:07,047
实际上我们曾在巴黎做了三小时的session

1049
01:16:07,303 --> 01:16:11,399
期待着我们的outage 的前进

1050
01:16:11,655 --> 01:16:17,799
我猜博物馆的故事有很多东西, 所以

1051
01:16:18,055 --> 01:16:21,383
我们不得不为那两个小时的短版本挑战.....这还有很多我们能改进的地方

1052
01:16:23,431 --> 01:16:28,295
比如我们找不到教练坐火车真正的价值类型

1053
01:16:28,551 --> 01:16:29,319
所以我们现在...

1054
01:16:29,575 --> 01:16:33,927
开始只让 coach 变为 immutable 的部分

1055
01:16:35,975 --> 01:16:36,743
也许

1056
01:16:38,023 --> 01:16:40,839
这确实还有很多事情需要改进...然后为了保证

1057
01:16:41,607 --> 01:16:42,887
它的私有性...也许

1058
01:16:45,447 --> 01:16:45,959
是的

1059
01:16:46,727 --> 01:16:47,751
避免

1060
01:16:48,775 --> 01:16:50,055
一些大的问题

1061
01:16:51,847 --> 01:16:54,663
去实现一个跟之前一样的构造函数

1062
01:16:55,431 --> 01:16:57,479
我现在可以去修复它

1063
01:16:57,991 --> 01:16:58,503
它的核心

1064
01:16:59,015 --> 01:16:59,527
是的，很好

1065
01:17:07,463 --> 01:17:08,231
因为那些已经存在了的代码

1066
01:17:08,487 --> 01:17:09,255
正在运行

1067
01:17:09,511 --> 01:17:10,791
所以...有些步骤你知道的

1068
01:17:11,047 --> 01:17:15,911
所以...得修复....这里...

1069
01:17:16,935 --> 01:17:21,543
所以是时候去修复它了

1070
01:17:21,799 --> 01:17:23,335
所以这里我们要拿到 coach

1071
01:17:23,847 --> 01:17:24,615
去添加 seats

1072
01:17:25,895 --> 01:17:26,407
所以

1073
01:17:26,663 --> 01:17:27,687
通过它...newCoach

1074
01:17:27,943 --> 01:17:30,759
没错, newcCoach...通过 Dictionary

1075
01:17:31,271 --> 01:17:33,319
 去跟踪它

1076
01:17:34,087 --> 01:17:37,415
所以现在测试还是红的吗？

1077
01:17:37,671 --> 01:17:41,767
但我猜当我在 Dictionary 中

1078
01:17:42,023 --> 01:17:44,327
保存了newCoach 的值之后，测试又会变回为绿的

1079
01:17:45,351 --> 01:17:45,863
newCoach

1080
01:17:48,167 --> 01:17:48,679
没错

1081
01:17:49,191 --> 01:17:50,471
Inevitable

1082
01:18:10,183 --> 01:18:10,951
Yeah...yeah

1083
01:18:18,375 --> 01:18:19,655
在测试里

1084
01:18:21,447 --> 01:18:23,751
和 coach 一起...okay

1085
01:18:31,175 --> 01:18:31,687
这里

1086
01:18:32,711 --> 01:18:34,759
你重新回到单元测试

1087
01:18:43,719 --> 01:18:44,999
是的是的，没错

1088
01:18:45,255 --> 01:18:46,791
完全正确

1089
01:18:52,679 --> 01:18:58,823
我们会这样做，因为我们想向您展示第二个架构和其他步骤....但你是正确的...你是对的

1090
01:19:03,431 --> 01:19:09,319
没错，绝对是。 但那是下一个点， 实际上我们有个一个 Train

1091
01:19:10,087 --> 01:19:11,623
已经对外暴露出了 seats 的集合， 并且也尝试去暴露coach 的集合

1092
01:19:11,879 --> 01:19:15,975
因为所有的 seats 都应该属于 coach，所以接下来我们要做的是

1093
01:19:16,231 --> 01:19:19,815
在 Train 中替换掉添加重复的集合

1094
01:19:20,071 --> 01:19:21,863
取而代之的是projection

1095
01:19:22,375 --> 01:19:24,679
然后在 Train 中 seats 的集合一定是

1096
01:19:24,935 --> 01:19:27,751
每个 coach 的所有的 seats 的projection

1097
01:19:27,751 --> 01:19:28,007
在 Train 中

1098
01:19:28,007 --> 01:19:29,031
让我们动手吧

1099
01:19:29,287 --> 01:19:32,359
select mini something like that

1100
01:19:32,871 --> 01:19:34,151
coaches

1101
01:19:35,431 --> 01:19:36,455
用每个 coach

1102
01:19:36,967 --> 01:19:39,527
 返回他的值

1103
01:19:40,039 --> 01:19:41,063
SelectMany

1104
01:19:46,695 --> 01:19:47,463
对于每个 seat 来说

1105
01:19:47,975 --> 01:19:49,767
改成 c

1106
01:19:50,023 --> 01:19:50,791
c dot

1107
01:19:51,047 --> 01:19:51,559
seats

1108
01:19:55,143 --> 01:19:56,167
toList

1109
01:19:56,679 --> 01:19:57,191
to a newList

1110
01:19:59,239 --> 01:20:02,823
这样就又把他们连在一起但这次是projection

1111
01:20:03,079 --> 01:20:03,847
我们用

1112
01:20:04,103 --> 01:20:05,895
每个 coach 身上的所有 seats

1113
01:20:06,407 --> 01:20:09,223
然后我们返回了它对于整个 train 而言

1114
01:20:09,735 --> 01:20:13,319
所以我们不需要重新 set 它了，因为

1115
01:20:13,575 --> 01:20:14,344
它现在是一个属性了

1116
01:20:18,952 --> 01:20:19,464
Ok

1117
01:20:23,048 --> 01:20:25,352
所以，我们编译了 coach....

1118
01:20:25,608 --> 01:20:27,144
看起来不错

1119
01:20:28,936 --> 01:20:31,752
也许我们能修复一个 bug

1120
01:20:32,008 --> 01:20:32,776
你觉得怎么样

1121
01:20:34,312 --> 01:20:35,336
可以

1122
01:20:36,872 --> 01:20:39,688
Absolutely...villages?...yes

1123
01:20:39,944 --> 01:20:43,016
我们是想将 findAvailableSeats or the buildReservationAttempt

1124
01:20:43,272 --> 01:20:44,296
移动到 coach 里去

1125
01:20:44,552 --> 01:20:46,600
因为如果我们在 train 中调用它

1126
01:20:47,368 --> 01:20:49,416
就没办法

1127
01:20:49,672 --> 01:20:53,256
合适的...只有一种比较蹩脚的办法

1128
01:20:53,512 --> 01:20:54,536
所以我们将它 delegate 到

1129
01:20:54,792 --> 01:20:57,608
Coach 中去吧。所以我把这个

1130
01:20:57,864 --> 01:20:58,376
删掉

1131
01:20:58,632 --> 01:21:01,704
所以我们的测试总是red-green

1132
01:21:01,960 --> 01:21:03,240
这样的节奏

1133
01:21:05,032 --> 01:21:08,872
现在让我们回到 WebTicket 中去

1134
01:21:09,128 --> 01:21:12,456
而且就像你建议的那样

1135
01:21:13,480 --> 01:21:14,248
也许

1136
01:21:14,760 --> 01:21:18,088
buildReservationAttempt 主要负责验证

1137
01:21:19,368 --> 01:21:21,928
and to tweet

1138
01:21:22,696 --> 01:21:23,464
一些新的东西

1139
01:21:25,768 --> 01:21:29,864
也许我们能改变算法

1140
01:21:30,376 --> 01:21:31,144
but respect algorithm

1141
01:21:31,400 --> 01:21:33,192
所以我基于 coach 来做这件事

1142
01:21:35,240 --> 01:21:36,776
让我们把

1143
01:21:37,032 --> 01:21:39,336
查找作为的逻辑

1144
01:21:39,592 --> 01:21:40,616
放在 coach 这层上

1145
01:21:42,664 --> 01:21:43,688
所以我们来 for 循环每个 coach

1146
01:21:44,712 --> 01:21:49,832
所以，真的要做一件相同的事，buildReservationAttemp, 没错，我喜欢用这个

1147
01:21:51,368 --> 01:21:52,136
please coach

1148
01:21:52,648 --> 01:21:54,696
beat me build reservation attemp 如果你可以的话

1149
01:21:55,464 --> 01:21:55,976
Ok

1150
01:21:59,304 --> 01:22:02,120
然后返回给你一个 reservcationAttempt

1151
01:22:02,376 --> 01:22:04,680
ReservcationAttempt

1152
01:22:05,192 --> 01:22:06,728
Is reservationAttempt

1153
01:22:07,240 --> 01:22:07,752
Adele

1154
01:22:13,384 --> 01:22:14,920
然后...如果...reservationAttempt

1155
01:22:15,176 --> 01:22:16,200
IsFulfilled

1156
01:22:16,456 --> 01:22:16,968
Ok

1157
01:22:17,736 --> 01:22:19,528
然后返回

1158
01:22:20,296 --> 01:22:22,088
reservationAttempt

1159
01:22:22,344 --> 01:22:26,952
如果不是, 我们继续遍历下一个 coach 去做相同的事

1160
01:22:27,208 --> 01:22:28,488
至少有一位 coach

1161
01:22:29,000 --> 01:22:32,072
我们可以拿到他的另一个 reservationAttempt，我们很高兴看到这样

1162
01:22:32,840 --> 01:22:33,352
所以

1163
01:22:33,608 --> 01:22:37,192
这部分代码实际上我希望

1164
01:22:37,448 --> 01:22:39,496
完全移动到

1165
01:22:40,520 --> 01:22:41,032


1166
01:22:43,080 --> 01:22:44,872
让我们创建一个方法

1167
01:22:51,272 --> 01:22:52,808
好的，实际上我并不是很喜欢剪切复制，

1168
01:22:53,320 --> 01:22:56,136
但这里

1169
01:22:57,928 --> 01:22:59,208
倒也合乎情理

1170
01:22:59,464 --> 01:23:05,608
好了，现在变绿了...所以我们刚才修复了一个 bug，也许你可以"红，绿，重构"

1171
01:23:08,936 --> 01:23:11,240
将 buildReservationAttempt 放到 train 这个层级上去

1172
01:23:11,752 --> 01:23:14,568
we still...let some code

1173
01:23:14,824 --> 01:23:15,336
所以

1174
01:23:15,848 --> 01:23:18,664
基于seat 上的东西

1175
01:23:19,176 --> 01:23:21,224
这里我们有一些

1176
01:23:21,480 --> 01:23:27,112
...copy过来的代码，所以让我们用 linq 来把它替换掉吧

1177
01:23:28,648 --> 01:23:32,744
So take me please 所有的 seats where BookingRef 是空的

1178
01:23:33,000 --> 01:23:35,560
空的...string 点  isNullOrEmpty

1179
01:23:36,328 --> 01:23:42,472
我们是否应该新创建一个方法

1180
01:23:42,728 --> 01:23:47,336
Take the number of seatsRequestCount

1181
01:23:47,592 --> 01:23:49,896
所以这里我们 project 了一个 可用的

1182
01:23:50,920 --> 01:23:51,432
seats

1183
01:23:51,944 --> 01:23:57,576
的集合，然后我们还有一个所有 seats 的集合，这样我们就能

1184
01:23:58,088 --> 01:24:04,232
传1，3，4 任何我要求的数字...我还要把这里也替换掉...

1185
01:24:04,488 --> 01:24:07,816
它确实做了在 seats 中和 foreach loop 相同的事

1186
01:24:09,096 --> 01:24:11,656
想那么做你不得不.....

1187
01:24:12,424 --> 01:24:14,216
...不得不.....选中全部

1188
01:24:14,472 --> 01:24:18,824
移除掉了

1189
01:24:20,104 --> 01:24:20,616
Ok

1190
01:24:22,408 --> 01:24:24,200
Ok 你移除掉了

1191
01:24:25,736 --> 01:24:26,504
这儿

1192
01:24:28,808 --> 01:24:29,576
Oops

1193
01:24:30,600 --> 01:24:31,112
我的错

1194
01:24:31,368 --> 01:24:32,136
现在没事了

1195
01:24:32,392 --> 01:24:38,536
所以我们可以做的似乎是 Seats 构造函数错过任何吸引.....东西
So what we can do maybe seems seat constructor missed up anything to attract mosquitoes

1196
01:24:38,792 --> 01:24:43,656
所以这里有一些不同

1197
01:24:46,984 --> 01:24:48,520
Inshallah ok

1198
01:24:52,616 --> 01:24:57,736
目标方法应该就叫

1199
01:24:58,248 --> 01:24:59,016
isAvailable

1200
01:25:00,040 --> 01:25:01,320
因为我们就是在 seats 上调用这个方法的

1201
01:25:02,088 --> 01:25:03,880
所以 non-static public

1202
01:25:05,160 --> 01:25:05,928
然后我们将

1203
01:25:06,184 --> 01:25:10,280
抽取方法并将它移动到 seat 中去

1204
01:25:10,536 --> 01:25:11,048
所以

1205
01:25:11,560 --> 01:25:12,328
移动它

1206
01:25:12,840 --> 01:25:17,192
现在，如果您可以通过请求放大链接

1207
01:25:17,704 --> 01:25:21,800
在seats上，我们可以使用所有可用的seats

1208
01:25:22,312 --> 01:25:25,384
而且我们采用我们需要的第一个数字

1209
01:25:32,040 --> 01:25:36,648
我们需要它. 那是我们为每个人实现的那个耳机

1210
01:25:37,928 --> 01:25:42,792
我应该做的另一次 reservation attempt

1211
01:25:43,048 --> 01:25:45,352
能够说获得良好的 reservation... 它的设计选择

1212
01:25:46,376 --> 01:25:47,400
Ok

1213
01:25:47,656 --> 01:25:50,216
我们很高兴修复了一个 bug

1214
01:25:50,472 --> 01:25:53,669
 修复 bug 能让我们的代码有一些小的提升

1
01:25:53,670 --> 01:26:04,620
那么下面是一个简短的关于聚合根的分享

2
01:26:04,620 --> 01:26:09,000
是的, 一个简短的分享. 聚合是一组实体或值对象的集合

3
01:26:09,000 --> 01:26:16,220
被当成是一个概念上的整体. 之前的例子中可以看出一些聚合的存在吗?

4
01:26:18,460 --> 01:26:30,470
火车? 对. 那么车厢是一个聚合吗? 不是
为什么呢? [因为它是火车座位的一部分,是不可变的] 是的, 一些聚合是可变的

5
01:26:30,470 --> 01:26:34,490
事实上它不是聚合, 因为聚合需要不变量, 需要业务规则

6
01:26:36,800 --> 01:26:42,560
还需要被强制执行
在我们的例子中

7
01:26:42,560 --> 01:26:49,130
唯一的可变量就是火车这一层

8
01:26:49,130 --> 01:26:53,600
业务的约束就是不能预定超过70%的火车票

9
01:26:53,600 --> 01:27:01,130
而在这个聚合里的车厢是被强约束的

10
01:27:01,130 --> 01:27:05,210
当我们和领域专家讨论的时候, 他告诉我们他希望添加一些新的关于车厢的规则

11
01:27:05,210 --> 01:27:11,000
像车厢不能够被完全订满, 以及不能超出给定的承载量

12
01:27:11,000 --> 01:27:15,980
如果是这种情况的话它就会成为一个聚合根
这些过于细节了

13
01:27:15,980 --> 01:27:22,850
但有趣的是, 火车 车厢和座位可能都是值对象

14
01:27:22,850 --> 01:27:28,760
像我们之前讨论的一样, 如果我去思考我们和外界后台系统交互的模式

15
01:27:28,760 --> 01:27:33,850
我们得到了一个在一段时间有效的快照

16
01:27:33,850 --> 01:27:40,280
我们也将会对此快照进行操作. 我们并不想将它们保存的缓存中
我们想直接操作那些聚合

17
01:27:43,340 --> 01:27:49,880
所以为了确保它, 我们可以将所有的对象都变成值对象

18
01:27:49,880 --> 01:27:53,090
实际上在现实项目的实现中我们是这样做的

19
01:27:53,090 --> 01:28:03,080
所以这意味着一些聚合可能全是值对象, [Audience]

20
01:28:03,080 --> 01:28:10,430
你是说这里的火车吗? 大部分情况下是的

21
01:28:10,430 --> 01:28:15,340
这里是一个特例[Audience]

22
01:28:27,380 --> 01:28:32,519
如果我们在车厢这一层有业务规则的约束的话

23
01:28:32,519 --> 01:28:37,289
是的, 在更详尽的版本里我们是这么设计的
那么到现在为止我们对Web ticket manager进行了改进

24
01:28:39,300 --> 01:28:45,179
之前的Reserve方法有几个屏幕的长度
到处都是无用的遗留的逻辑

25
01:28:45,179 --> 01:28:50,880
我想我们完成了一定程度的改善, 现在这个方法只有一屏幕的长度

26
01:28:50,880 --> 01:28:56,309
代码使用了领域的词汇来命名
我们称之为通用语言

27
01:28:56,309 --> 01:29:02,130
我们提出一些行为逻辑
并把它们放到了合理的地方

28
01:29:02,130 --> 01:29:07,769
但还有一些地方让我们不爽
也就是我们之前说到的

29
01:29:07,769 --> 01:29:15,959
这里返回了json格式的
在这个领域方法里返回了可恶的json

30
01:29:15,959 --> 01:29:22,110
我们这里的返回值还是string的task对象
也是一个json 是的

31
01:29:22,110 --> 01:29:28,380
所以我们想做的是干掉这个设计
用Reserve来替代它

32
01:29:28,380 --> 01:29:35,579
对不起, 是Reservation
那么Reserve方法就可以返回一个Reservation

33
01:29:35,579 --> 01:29:41,249
然后, 在基础设施层
如果有适配器之类的话

34
01:29:41,249 --> 01:29:45,989
我们会把reservation转换成json的形式

35
01:29:45,989 --> 01:29:50,340
现在我觉得我们可以分享下面部分的内容

36
01:29:50,340 --> 01:29:52,979
抱歉

37
01:29:52,979 --> 01:30:00,179
我会继续重构这个代码, 你可能看不到过程
但我们一会儿会回到代码来解释

38
01:30:00,179 --> 01:30:04,380
我们的架构以及我们做了一些什么

39
01:30:04,380 --> 01:30:10,590
好的
那么谁听说过六边形架构?

40
01:30:10,590 --> 01:30:18,420
好的, 太棒了
六边形架构是由

41
01:30:18,420 --> 01:30:24,090
Alistair Cockburn提出的
我记不清了, 大概是很久之前

42
01:30:24,090 --> 01:30:28,940
它有很多的优点. 它是一个架构级的设计模式
它以拥抱变化著称

43
01:30:33,620 --> 01:30:40,370
Alistair最初的想法是可以做到插入和移除依赖

44
01:30:40,370 --> 01:30:46,460
插入和移除一些东西. 他探讨了关于系统是否应该
被插入很多的依赖作为输入

45
01:30:46,460 --> 01:30:51,260
以及很多依赖作为输出

46
01:30:51,260 --> 01:30:56,780
将新闻广播出去, 广播到电视, 广播到任意媒介
所以内部的代码是相对整洁的

47
01:31:00,830 --> 01:31:07,220
每一个对于I/O或系统交互的修改

48
01:31:07,220 --> 01:31:12,290
都不是一个event, 而是一些可以随时插入或移除的东西

49
01:31:12,290 --> 01:31:17,900
就是这么简单. 所以这个架构就是基于这种思想被提出的

50
01:31:17,900 --> 01:31:25,040
但当我们思考如何使用它的时候, 我们首先会想到

51
01:31:25,040 --> 01:31:30,320
在领域内部使代码更有业务价值

52
01:31:30,320 --> 01:31:36,310
保护我们的领域代码不受技术性的代码的影响.
我不知道你们是怎么想的

53
01:31:36,310 --> 01:31:40,790
在过去很长时间, 我觉得几乎不可能合理地

54
01:31:40,790 --> 01:31:46,070
分离业务逻辑和技术性支撑代码.
我们尝试过很多次以后似乎我理解了这个模式

55
01:31:46,070 --> 01:31:51,880
它是一种非常棒的解决方案

56
01:31:51,880 --> 01:31:56,330
我还希望保证可测试性,
正是因为所有的东西都是可插入可移除的

57
01:31:56,330 --> 01:32:02,150
因此我们可以采用stub, 我们可以采用mock

58
01:32:02,150 --> 01:32:07,730
我们可以stub系统的输入和输出, 内部的系统逻辑

59
01:32:07,730 --> 01:32:12,350
今天我们会更多地关注如何保护我们的领域代码
那么它是怎么工作的呢?

60
01:32:12,350 --> 01:32:16,460
将我们的世界想象成两个部分
内部和外部

61
01:32:16,460 --> 01:32:21,440
非常简单对吧?
没有几千个层级

62
01:32:21,440 --> 01:32:27,410
非常简单, 两个部分  内部是我们的领域代码
比如Reserve方法, 比如Train

63
01:32:27,410 --> 01:32:30,680
比如ReservationAttempt之类的

64
01:32:30,680 --> 01:32:36,560
基础设施代码则在我们系统的外部

65
01:32:36,560 --> 01:32:39,710
这里可能有你喜爱的HTTP工具类

66
01:32:39,710 --> 01:32:43,520
你的数据库引擎, 你的消息中间件
你最喜欢的各种解决方案等等

67
01:32:43,520 --> 01:32:47,110
这就是基础设施的部分
我们想做的第一步是优化我们的业务代码

68
01:32:50,390 --> 01:32:56,390
首先我们希望给内部领域代码加一个带刺的铁丝网

69
01:32:56,390 --> 01:33:03,080
定义一些入口和出口

70
01:33:03,080 --> 01:33:08,810
因此可以让基础设施代码留在另外一端

71
01:33:08,810 --> 01:33:15,860
这实际上是一个非常好的能力
因为可能在开始你的程序员生涯的时候

72
01:33:17,660 --> 01:33:21,260
你需要提高你的技能, 你需要尝试新鲜的东西
你需要犯很多的错误

73
01:33:21,260 --> 01:33:26,270
你需要为了某些目的实现自己的框架

74
01:33:26,270 --> 01:33:30,140
到某一时刻,你会开始意识到自己做过一些愚蠢的事情
像实现自己的框架之类的

75
01:33:30,140 --> 01:33:36,230
但是在你真正开始关注领域之前
对一些年轻的程序员来说

76
01:33:38,750 --> 01:33:43,370
确实需要一个练手的地方
我很认同这件事

77
01:33:43,370 --> 01:33:48,500
只要它不会破坏业务逻辑和项目

78
01:33:48,500 --> 01:33:51,800
如果是这样的话, 我完全没问题
因为这个区域是你可以练习的地方

79
01:33:51,800 --> 01:33:56,180
在基础设施代码这里就是一个练手的地方
你可以尝试新技术, 新东西

80
01:33:56,180 --> 01:34:01,130
而且不会破坏业务代码
这是我非常喜欢这个模式的地方

81
01:34:01,130 --> 01:34:05,719
那么它是如何工作的
因为有铁丝网

82
01:34:05,719 --> 01:34:09,560
但我需要进入或离开这个建筑
也就是跳出领域代码

83
01:34:09,560 --> 01:34:13,880
所以, 为了解除依赖
所有的依赖都是朝向内部的

84
01:34:13,880 --> 01:34:17,330
基础设施代码知道业务代码的存在
并可以调用它们

85
01:34:17,330 --> 01:34:22,489
但业务代码不会意识到使用了哪种框架

86
01:34:22,489 --> 01:34:29,110
即使是关于json的东西所以业务领域是完全独立于任何一种技术的

87
01:34:29,110 --> 01:34:36,770
即使是json字符串或类似的东西

88
01:34:36,770 --> 01:34:42,800
所以让我们能够从内部访问到外部的新东西

89
01:34:42,800 --> 01:34:47,870
和外部的web api交互
我们是基于端口和适配器的

90
01:34:47,870 --> 01:34:53,180
为了实现此目的我们采用的是依赖注入原则

91
01:34:53,180 --> 01:34:58,160
所以从内部我们可以对外部进行操作

92
01:34:58,160 --> 01:35:04,130
Alistair Cockbrun最近和另外一个人的讨论

93
01:35:04,130 --> 01:35:07,910
我记不清名字了
他们提出了configurable dependencies

94
01:35:07,910 --> 01:35:12,920
Alistair提出的
dependency injection principle

95
01:35:12,920 --> 01:35:17,840
我不是十分的认同, 因为它是一种被动的规范方法

96
01:35:17,840 --> 01:35:23,900
我们都很习惯于这样做, 习惯于反转
所以他用一种更直接表达意图的方式来描述它

97
01:35:27,080 --> 01:35:32,660
因此称为了configurable dependencies
用来插入和移除你的业务代码的依赖

98
01:35:32,660 --> 01:35:41,420
所以我们回到刚才的例子

99
01:35:41,420 --> 01:35:47,420
我们说我们已经有了领域的入口的出口

100
01:35:47,420 --> 01:35:52,550
端口是属于领域的
这里有一些接口,像棒棒糖形状的图形这里

101
01:35:52,550 --> 01:35:57,440
这里有一个IReserveSeats
是Train Train系统的入口

102
01:36:00,770 --> 01:36:07,340
这里有一个HTTP适配器,  适配器会有一个回调
我必须调用一个接口, 也是一个端口

103
01:36:07,340 --> 01:36:14,930
我有一个座位号
跟它说请给我预定一下

104
01:36:14,930 --> 01:36:19,190
然后我拿到一个reservation
适配器会做reservation和json之间的转换

105
01:36:23,810 --> 01:36:29,840
因为这里处理的是json, 而且是一个rest适配器,
所以是最合适的位置做这件事

106
01:36:29,840 --> 01:36:35,090
当我的业务逻辑需要一些额外的数据, 开始的时候没有提供给我的东西

107
01:36:35,090 --> 01:36:41,270
有许多种实现的方法
但假如说我需要访问外部的SSL依赖

108
01:36:41,270 --> 01:36:47,390
就是我们刚才提到的需要访问的外部三个web api

109
01:36:47,390 --> 01:36:52,160
我们需要在外部添加一些东西
为了实现这个我们需要访问内部的端口

110
01:36:54,940 --> 01:37:00,680
包括IBookSeats
IProvideTrainTopology

111
01:37:00,680 --> 01:37:05,840
以及IGetBookingRef接口

112
01:37:05,840 --> 01:37:09,270
这些都是领域接口
端口还是属于领域内的

113
01:37:09,270 --> 01:37:14,010
这也是为什么棒棒糖这里是蓝色的

114
01:37:14,010 --> 01:37:17,970
但是适配器是属于基础架构的

115
01:37:17,970 --> 01:37:22,170
所以可以说适配器就是用来做基础设施代码和领域模型之间的映射的

116
01:37:22,170 --> 01:37:28,620
我解释清楚了吗

117
01:37:28,620 --> 01:37:36,060
好, 我们一会儿会在代码里再看到
所以端口和适配器就是控制进出, 很简单对吧

118
01:37:36,060 --> 01:37:40,650
好
但是当我们最初尝试实现它的时候产生了无数的问题

119
01:37:45,540 --> 01:37:50,880
有许多实现的方法. 我们会展示其中一个
我们需要初始化

120
01:37:50,880 --> 01:37:59,520
你需要自己创建这个东西
我之前用一个比喻

121
01:37:59,520 --> 01:38:02,670
叫做key ring解释给我的伙伴
现在也用它给你们解释一下

122
01:38:02,670 --> 01:38:07,710
首先第一步
我们这里将要讨论的是utopian应用的构成

123
01:38:07,710 --> 01:38:11,700
在你的应用里构造所有的依赖

124
01:38:11,700 --> 01:38:17,070
voila, 应用到系统里一切就工作了

125
01:38:17,070 --> 01:38:22,320
所以我们将要讨论的是如何建立起你的应用

126
01:38:22,320 --> 01:38:27,000
所以一共有三步
第一步是创建"I need to go out"适配器

127
01:38:27,000 --> 01:38:32,760
所有的适配器将会向后台的SSL要一个"please give me a topology"

128
01:38:32,760 --> 01:38:36,360
所以这里我们有两个适配器, Train Data Service Adapter
和Booking Reference Service Adapter

129
01:38:38,340 --> 01:38:44,460
它们就像向外面请求信息的钥匙
所以第一步就是获得这些钥匙

130
01:38:44,460 --> 01:38:49,980
第二步是我已经获得了这些钥匙, 我要把他们封装到领域内部

131
01:38:52,200 --> 01:38:57,330
六边形就是对应领域模型
这是一个web ticket manager

132
01:38:57,330 --> 01:39:01,440
所以web ticket manager会通过ports和外部世界交互

133
01:39:01,440 --> 01:39:09,930
然后我们会用新的将会和我们系统交互的适配器

134
01:39:09,930 --> 01:39:14,400
封装六边形

135
01:39:17,250 --> 01:39:22,890
我需要访问适配器
这是和我们应用通信的方法

136
01:39:22,890 --> 01:39:27,660
在我们做完这些之后
从应用的角度 从Asp.NET web api的角度

137
01:39:29,570 --> 01:39:35,070
我需要拥有的就只有入口适配器

138
01:39:35,070 --> 01:39:39,540
所以六边形和其他的适配器

139
01:39:39,540 --> 01:39:46,590
都是实现细节
在我们实现完以后

140
01:39:46,590 --> 01:39:51,660
对于Web api来说需要知道的就只有这个适配器

141
01:39:51,660 --> 01:39:58,110
也就是我们系统的入口

142
01:39:58,110 --> 01:40:04,199
好的 从另一个角度来看
从图中看一下这三个步骤

143
01:40:04,199 --> 01:40:07,980
第一步我们创建了我们"I need to go out"适配器, 对应三个后台
然后我们将它们和这个六边形

144
01:40:07,980 --> 01:40:13,440
也就是和领域模型封装起来
就像俄罗斯套娃一样

145
01:40:13,440 --> 01:40:18,000
我需要出去 然后是六边形
然后我需要进去

146
01:40:18,000 --> 01:40:21,660
最后你就只需要进去的接口

147
01:40:21,660 --> 01:40:26,270
也就是对应用来说
唯一和系统进行交互的接口

148
01:40:26,270 --> 01:40:30,960
所以所有你需要知道的就只有这个适配器
注入到你的回调里

149
01:40:30,960 --> 01:40:38,489
像是controller等等的地方
有问题吗

150
01:40:41,400 --> 01:40:51,440
我们要写代码了 希望你们会有一些问题
所以我们来看看新版本的代码

151
01:40:51,440 --> 01:41:00,080
你可以注意到我们有了Reservation
这里的改动是调用了confirm方法

152
01:41:00,080 --> 01:41:09,410
因为这一行后面我可以确定没有exception
所以我就可以返回reservation

153
01:41:09,410 --> 01:41:16,230
对于测试的改动是这里
对

154
01:41:16,230 --> 01:41:23,429
我们返回一个reservation 我已经创建了一个适配器的开头
这是一个output适配器

155
01:41:23,429 --> 01:41:31,380
包含一个AdaptReservation方法
这个方法几分钟后会被Thomas调用

156
01:41:31,380 --> 01:41:35,199
所以你已经开始将json的技术实现移到合适的地方
没错 好的

157
01:41:38,469 --> 01:41:44,499
那我觉得我可以先完成第一个单元测试

158
01:41:44,499 --> 01:41:53,229
我需要来实现我的构建过程
好的, 第一步就是

159
01:41:53,229 --> 01:41:58,539
创建"I want to go out"适配器
比如这里 trainDataService 我们甚至可以重命名为trainDataServicesAdapter

160
01:42:00,820 --> 01:42:05,949
这是个糟糕的名字 它实际不是一个service
它在那里

161
01:42:05,949 --> 01:42:14,439
它也是一个代理
对于bookingReferenceServiceAdapter也是一样的

162
01:42:14,439 --> 01:42:17,349
好的 第一步我建立了对外界的依赖

163
01:42:17,349 --> 01:42:24,489
好的, 我现在需要的是创建六边形
实际上这里的六边形就是web ticket manager

164
01:42:27,189 --> 01:42:35,260
所以我们这里暂时叫做hexagon

165
01:42:35,260 --> 01:42:41,039
现实中你会用一个有业务含义的名字
所以不要告诉Eric我们这样做

166
01:42:45,280 --> 01:42:48,999
我这样做是因为我们现在在讲六边形和基础设施之间的关系

167
01:42:48,999 --> 01:42:53,349
所以我这里暂时命名为hexagon

168
01:42:53,349 --> 01:42:58,719
那么hexagon是不应该被直接调用的

169
01:42:58,719 --> 01:43:01,599
我之前说过应用会通过adapter和业务逻辑交互

170
01:43:01,599 --> 01:43:06,939
所以让我们来定义它 是的
第三步创建"I want to go in"适配器

171
01:43:06,939 --> 01:43:13,269
这里 我们应该起什么名字

172
01:43:13,269 --> 01:43:20,409
哦 这里 你已经定义好了 应该是一样的名字
所以我会创建它 提供我需要提供的 hexagon

173
01:43:25,059 --> 01:43:30,159
是的 就像俄罗斯套娃 所以这两个的适配器用来创建hexagon
然后hexagon用来生成这个对象

174
01:43:32,829 --> 01:43:39,189
好的 我创建了一个构造函数 因为到现在为止你只定义了一个static方法

175
01:43:39,189 --> 01:43:44,709
好的 你可能需要做一下抽象
不应该注入webTicketManager

176
01:43:48,969 --> 01:43:53,590
是的 事实上你是对的, 我们谈到过端口
端口就像接口

177
01:43:53,590 --> 01:44:00,429
所以我可以做的 是对webTicketManager
提出一个接口

178
01:44:00,429 --> 01:44:06,670
这个名字不够好 我们后面会改
所以让我们提出一个接口

179
01:44:06,670 --> 01:44:20,170
就叫做IReserveSeats 像这样
对不起 我之前工作在mac上

180
01:44:20,170 --> 01:44:25,300
所以我们试着选一个合适的键盘
IReserveSeats

181
01:44:25,300 --> 01:44:33,039
你每天都工作在pc上啊
是的 我在试着找个借口啊

182
01:44:33,039 --> 01:44:44,729
现场压力 是的
所以我在这个接口中添加了reserve方法

183
01:44:44,729 --> 01:44:49,929
这里 这是一个端口
用来访问领域模型

184
01:44:49,929 --> 01:44:56,559
那么回到代码中 我给这个适配器传入的
是hexagon

185
01:44:56,559 --> 01:45:04,150
oops 跳转到它的实现
应该是IReserveSeat

186
01:45:07,860 --> 01:45:16,150
好 我还是将它设为私有属性
这里我将需要它

187
01:45:16,150 --> 01:45:22,689
所以我定义好了reservation adapter
okay 第三步是创建reservation adapter

188
01:45:22,689 --> 01:45:29,469
让我们把它抽成 reservationAdaper okay
我的想法将对hexagon直接的调用

189
01:45:29,469 --> 01:45:34,959
替换成通过适配器的调用

190
01:45:34,959 --> 01:45:40,539
所以为了让它编译通过
先到web controller里

191
01:45:40,539 --> 01:45:46,479
这是要调用适配器的地方

192
01:45:46,479 --> 01:45:53,079
所以在controller中 首先将是获得reservation request dto
所以会有一个reservation request dto

193
01:45:54,909 --> 01:45:59,710
我会将reservation dto传到适配器
它将会返回一个reservation的json 对吧

194
01:45:59,710 --> 01:46:06,590
那么我觉得reservation dto不在合适的地方

195
01:46:06,590 --> 01:46:11,420
在测试中无法访问到它

196
01:46:11,420 --> 01:46:16,580
所以我建议我们移动一下它的位置

197
01:46:16,580 --> 01:46:21,830
创建新的工程比较痛苦 时间较长
所以我就只创建一个文件夹

198
01:46:21,830 --> 01:46:25,850
我会创建一个Train Train下面的domain和infra文件夹

199
01:46:25,850 --> 01:46:33,620
所以我们可以合理地分离出各种类型
隔离出基础设施
所以我们将其放到合适的位置

200
01:46:36,590 --> 01:46:43,190
选择move type into matching files
来确保每个类型都是对应的文件

201
01:46:45,860 --> 01:46:53,090
BookingReferenceService 我应该放到哪儿
domain还是infra

202
01:46:53,090 --> 01:47:02,200
这个名字不好 正常情况下它肯定会有更好的名字
是的 应该放到infra里
yeah coach

203
01:47:02,200 --> 01:47:11,600
coach类 放到domain 对 IBookingReferenceService
它是一个接口 所以它是一个端口

204
01:47:11,600 --> 01:47:20,570
所以应该是放到domain里 IReservedSeats
端口 所以是domain 没错

205
01:47:21,950 --> 01:47:29,090
ITrainDataservice
它应该在domain下面 它是一个接口

206
01:47:29,090 --> 01:47:35,860
yeah reservation 应该是domain
reservationAttempt 一样
reservationAttemptFailure 也是一样

207
01:47:39,640 --> 01:47:43,820
reservationFailure 也是一个domain

208
01:47:45,290 --> 01:47:49,340
实际上给它一个更合适的名字它会有更多的价值

209
01:47:49,340 --> 01:47:55,430
seats? domain. 我很开心
我们的domain相比infrastructure更多

210
01:47:55,430 --> 01:48:02,740
到目前为止我的项目都不是这样的
那么SeatJsonPoco, infra

211
01:48:03,370 --> 01:48:10,280
SeatsReservationAdapter? adapter肯定是infrastructure下面的

212
01:48:10,280 --> 01:48:15,060
ThreadsholdTrainCapacity? domain, 绝对是

213
01:48:15,060 --> 01:48:24,030
即使我们起不出更好的名字 Train? domain
我们还剩什么TimeDataSservice, infrastructure 它是适配器

214
01:48:28,620 --> 01:48:36,450
那么WebTicketManager, domain. 它是hexagon

215
01:48:36,450 --> 01:48:45,480
不过到现在为止它还有两个http服务相关的依赖

216
01:48:45,480 --> 01:48:48,230
我们暂时还是把它放在这里

217
01:48:49,370 --> 01:48:54,390
在我们把这里打扫干净之前还是把它放在根目录

218
01:48:54,390 --> 01:48:57,930
修改一下命名空间
是的 应该修改一下项目的命名空间

219
01:48:57,930 --> 01:49:03,060
那么所有的文件应该都放在了正确的地方

220
01:49:03,060 --> 01:49:16,080
我刚才说到了
我应该找到测试 TrainTrainShould 让我们回到测试

221
01:49:19,080 --> 01:49:22,620
好的 我刚才提到我希望引入和ReservationAdapter交互的途径

222
01:49:22,620 --> 01:49:28,680
让我们先称之为Post dto
应该可以找到更好的名字 但是

223
01:49:28,680 --> 01:49:34,440
这里应该是new reservation request
我不确定你是否移动过它

224
01:49:36,630 --> 01:49:43,530
我不确定 我应该没有移
哦对 ReservationRequestDto

225
01:49:43,530 --> 01:49:54,390
它在错误的项目里 我需要把它移过来
移到TrainTrain下的infra文件夹里

226
01:49:54,390 --> 01:50:00,360
所以现在我可以在测试中引用它了
否则它是web api的一部分的话就没办法引用到

227
01:50:03,630 --> 01:50:10,290
好的 所以现在我会创建一个新的reservation request dto
因为这是ASP.net的项目

228
01:50:10,290 --> 01:50:16,290
通常它会帮我初始化
但是这里number_of_seats

229
01:50:16,290 --> 01:50:23,530
对应的是seatsRequestedCount
另外一个是train_id

230
01:50:23,530 --> 01:50:29,890
设置成和我们接受的输入json相等的

231
01:50:29,890 --> 01:50:33,520
它是一个poco 也就是TrainId

232
01:50:33,520 --> 01:50:42,570
对应我们的train
所以这里我post一个新的请求dto

233
01:50:46,900 --> 01:50:56,020
我们也许可以抽一个变量 看起来更整洁
所以我们现在有了reservationRequestDto

234
01:50:56,020 --> 01:51:01,240
然后我用适配器post这个reservation的请求
我想进入适配器 创建这个方法 好的

235
01:51:03,550 --> 01:51:11,200
我将返回json string而不是void

236
01:51:11,200 --> 01:51:17,710
这里我可以返回asp.net内部的类作为response

237
01:51:17,710 --> 01:51:21,940
但今天我不会具体做了

238
01:51:21,940 --> 01:51:29,640
所以这里是reservation dto
所以这里的post方法

239
01:51:29,640 --> 01:51:36,390
应该返回给我一个
jsonReservation

240
01:51:36,390 --> 01:51:40,390
为什么不呢
所以适配器会给我返回这个

241
01:51:40,390 --> 01:51:46,260
我将对它进行断言
所以删掉整个

242
01:51:46,410 --> 01:51:51,940
然后jsonReservation就应该和这个json相等
对 期待的结果

243
01:51:51,940 --> 01:51:56,740
它还是对的 因为我还没有引入适配器

244
01:51:56,740 --> 01:52:03,160
适配器一共有三步来创建整个六边形架构

245
01:52:03,160 --> 01:52:09,480
我的意思是每个适配器的方法基本上都需要三个步骤

246
01:52:09,480 --> 01:52:13,440
第一步是讲基础设施代码转化为领域模型

247
01:52:13,440 --> 01:52:18,190
第二步是调用业务逻辑代码

248
01:52:18,190 --> 01:52:23,800
然后第三步是将领域代码的结果在转化为基础架构代码

249
01:52:23,800 --> 01:52:29,860
这就是每个方法实现的思路
所以让我们实现它 在这种情况下我不需要适配

250
01:52:31,540 --> 01:52:34,679
所以这里我为number_of_seats引入一个新的变量

251
01:52:34,679 --> 01:52:40,800
reservationRequestDto

252
01:52:40,800 --> 01:52:47,640
在现实中你可能需要自己来实现序列化的技术

253
01:52:47,640 --> 01:52:53,040
因为asp.net帮我为我们做了
但有时你需要用本地变量翻译json

254
01:52:53,040 --> 01:52:59,820
并转化成领域模型
我刚才做的就是定义了一些变量

255
01:52:59,820 --> 01:53:04,500
但这里时机就是你将要翻译 转换 调整的地方

256
01:53:04,500 --> 01:53:10,110
以此达到能够调用到业务逻辑的目的
好的 现在我用hexagon.Reserve()

257
01:53:10,110 --> 01:53:16,679
它是一个业务领域方法

258
01:53:16,679 --> 01:53:23,640
我已经定义了本地变量trainId numberOfSeats
让我把它改成numberOfSeatsRequested

259
01:53:23,640 --> 01:53:36,900
好的 我调用了hexagon的方法
它返回给我一个reservation

260
01:53:37,830 --> 01:53:43,710
因为它是一个async方法因此我需要在这里await

261
01:53:43,710 --> 01:53:49,500
对 这是c#用来实现异步的方法

262
01:53:49,500 --> 01:53:54,840
因为reserve方法也调用了其他的async方法
所以我也必须这样做

263
01:53:54,840 --> 01:54:01,020
接下来是讲领域模型映射回基础设施
这个方法Bruno已经实现了

264
01:54:01,020 --> 01:54:05,300
adapterReservation 参数是reservation的string

265
01:54:05,300 --> 01:54:12,090
对 直接返回
所以大家可以看到我从业务代码中得到一个reservation

266
01:54:12,090 --> 01:54:22,230
然后我做的事就是将其适配到json
这是还是红的 我错在哪儿了

267
01:54:26,610 --> 01:54:29,689
这里

268
01:54:32,430 --> 01:54:44,650
这里你也需要await
对不起 现在编译通过 是async/await的问题

269
01:54:47,020 --> 01:54:52,780
这是第一次用asp.net实现
所以可以在第一个验收测试里看到

270
01:54:54,460 --> 01:54:59,530
创建应用所需要做的
我不知道你们觉得接下来做什么比较好

271
01:54:59,530 --> 01:55:08,650
我们只剩不到10分钟了
这一部分其实应该放到application的启动阶段

272
01:55:08,650 --> 01:55:13,000
我可以接着做这个
把它插入到web ticket manager

273
01:55:13,000 --> 01:55:18,370
也许留一些问答的时间更好
或者用来总结一下

274
01:55:18,370 --> 01:55:21,969
你们觉得呢
我需要加速了

275
01:55:21,969 --> 01:55:35,320
因为时间有一点不够了
总结一下 我们从一个场景开始

276
01:55:35,320 --> 01:55:42,130
我们有一个web ticket manager
其中有非常多过程式的代码

277
01:55:42,130 --> 01:55:48,450
然后我们把它重构得风格更一致

278
01:55:48,450 --> 01:55:56,370
我不知道怎么说
更短更整洁的代码

279
01:55:56,370 --> 01:56:02,800
重构后的Reserve方法是这样的
这就是我们主要做的事

280
01:56:02,800 --> 01:56:09,489
最重要的是我们在代码中尽可能使用了领域语言
它之前是遗留代码 非常糟糕

281
01:56:12,430 --> 01:56:17,469
如果我们有时间运行一下

282
01:56:17,469 --> 01:56:25,050
警告会得更少

283
01:56:25,050 --> 01:56:30,160
我们的代码基本上是围绕reservation train

284
01:56:30,160 --> 01:56:35,710
reservationAttempt isFulfilled

285
01:56:35,710 --> 01:56:42,469
你看即使我们的领域专家读不懂我们的代码
我们也可以边看代码边解释给他

286
01:56:42,469 --> 01:56:49,070
可以进行讨论
然后他就可以说 不对

287
01:56:49,070 --> 01:56:54,340
这不是我想要的

288
01:56:54,340 --> 01:57:00,199
所以这样可以减少我们的实现和讨论之间的摩擦, 减小分歧
尊重他的意见会更好

289
01:57:04,360 --> 01:57:11,810
是的 我们有一个叫ndepend的工具
马上会给你们展示

290
01:57:11,810 --> 01:57:19,310
但是切换屏幕比较花时间
我们先做一个最后的总结

291
01:57:19,310 --> 01:57:23,810
今天我们没有时间让你体验
因为我们的领域专家在巴黎

292
01:57:23,810 --> 01:57:29,120
我们和他设计的第一版系统已经在stage了
和你们的领域专家讨论是非常关键的

293
01:57:31,429 --> 01:57:36,710
大部分出问题的项目都是因为
程序员甚至不被允许和领域专家讨论

294
01:57:36,710 --> 01:57:41,239
对我来说, 如果是这样我肯定不会去这个项目. 但在我的职业生涯的开端

295
01:57:43,370 --> 01:57:50,300
并不是这样. 它需要勇气时间和决心来执行它.

296
01:57:50,300 --> 01:57:58,120
但它非常关键
下一点是不要被遗留代码吓退

297
01:57:58,120 --> 01:58:04,610
因为我是一个教练
我学习如何重构代码

298
01:58:04,610 --> 01:58:09,560
一般代码有一些依赖的时候会说
我的这个代码是不可测的

299
01:58:09,560 --> 01:58:16,820
我们可以测试任何的代码
所以不要被吓到
你要这么做是需要勇气的

300
01:58:21,530 --> 01:58:27,080
是的 它会花很多时间 但是可以实现的

301
01:58:27,080 --> 01:58:30,260
今天我们没有用很多的手法
主要用到的是Martin Fowler的重构一书里的两个方法

302
01:58:30,260 --> 01:58:35,780
它们是提取和移动方法
非常简单 首先第一步是要有测试覆盖

303
01:58:38,199 --> 01:58:44,739
然后就可以非常容易的提取和移动
更复杂的是找到更合适的命名

304
01:58:44,739 --> 01:58:53,640
在领域设计上投资
我们的代码在你们的建议下有了很大改进

305
01:58:53,640 --> 01:58:57,930
非常的生动有趣

306
01:58:57,930 --> 01:59:05,730
你们非常积极的和我们互动 非常感谢

307
01:59:07,190 --> 01:59:12,340
[鼓掌]
