1
00:00:00,256 --> 00:00:06,400
大家准备好了吗？好了？好，那我们开始。

2
00:00:08,192 --> 00:00:12,800
第一个问题，当把DDD这个概念

3
00:00:13,056 --> 00:00:15,616
运用到项目或者代码里的时候，

4
00:00:15,872 --> 00:00:18,944
你们有谁遇到了困难？

5
00:00:19,968 --> 00:00:26,112
好吧，看来大家都有这样的困惑。我确实

6
00:00:26,368 --> 00:00:28,160
看到过很多关于DDD的讨论。

7
00:00:28,416 --> 00:00:28,928
我

8
00:00:29,184 --> 00:00:32,000
也试过把DDD用在遗留代码上。

9
00:00:34,768 --> 00:00:35,536
这就是我们举行这个会议的原因。

10
00:00:37,120 --> 00:00:43,264
没错。这次我们主要讨论技术模式。

11
00:00:44,032 --> 00:00:50,176
主要讲一下怎样把你的领域知识放到

12
00:00:50,432 --> 00:00:51,456
代码中。

13
00:00:51,712 --> 00:00:54,272
我们也会稍微涉及一些战略模式，不过不会仅限于此。

14
00:00:54,784 --> 00:00:58,112
但是整个会议呢，还是比较

15
00:00:58,368 --> 00:00:59,392
偏向技术的。

16
00:00:59,648 --> 00:01:04,000
我们进行下一步之前先介绍一下自己吧？

17
00:01:06,048 --> 00:01:12,192
嗯好。我是Bruno Boucard。是来自巴黎的讲师。

18
00:01:12,448 --> 00:01:18,080
我教TDD，BDD和DDD。

19
00:01:18,592 --> 00:01:20,640
我现在负责

20
00:01:20,896 --> 00:01:22,688
巴黎的BDD会议。

21
00:01:23,456 --> 00:01:26,784
我是Thomas Pierrain。

22
00:01:27,040 --> 00:01:33,184
我18岁以来就从事软件工作。我也是巴黎DDD会议的组织者之一。

23
00:01:33,440 --> 00:01:35,488
我更倾向于

24
00:01:35,744 --> 00:01:36,512
基于问题。

25
00:01:36,768 --> 00:01:40,096
因为我认为我们太快进入基于解决方案了。

26
00:01:40,352 --> 00:01:42,912
我们周围的好多都是基于解决方案的。

27
00:01:43,424 --> 00:01:45,472
这是我的一个发现。

28
00:01:45,984 --> 00:01:49,056
好，我们为大家准备了

29
00:01:49,568 --> 00:01:50,080
一些礼物。

30
00:01:50,336 --> 00:01:51,872
这有两本书。

31
00:01:52,384 --> 00:01:58,528
蓝色的这本，还有Martin Fowler的重构。

32
00:01:59,808 --> 00:02:03,904
如果想赢得这些书，大家得在会议期间多发推文。

33
00:02:04,160 --> 00:02:10,304
并加上#DDDEU。

34
00:02:10,560 --> 00:02:11,840
我们这有一个裁判。

35
00:02:12,096 --> 00:02:17,216
他到时候会去看这个标签。最有趣的

36
00:02:17,472 --> 00:02:23,616
推文将会获奖。大家可以录像，可以照相，可以开我们的玩笑，也可以开你们自己的玩笑，怎样都行。

37
00:02:23,872 --> 00:02:28,480
John会在会议最后公布最终的两个获奖人。好吗？

38
00:02:30,784 --> 00:02:33,344
我们今天来说说火车领域。

39
00:02:34,624 --> 00:02:40,768
火车领域其实还挺大的。我们今天主要关注怎么来优化座位预定。

40
00:02:42,304 --> 00:02:48,448
这是一个火车模型。这个火车有三个车厢，A，B和C。

41
00:02:48,960 --> 00:02:50,240
橙色的代表

42
00:02:50,496 --> 00:02:53,312
已经被预定的座位。

43
00:02:53,568 --> 00:02:55,104
白色的代表空座位。

44
00:02:55,360 --> 00:02:58,176
现在我们要预定6个座位

45
00:02:58,688 --> 00:03:04,832
蓝色的这6个。这是个比较简单的模型，这个图也有助我们的理解。

46
00:03:05,088 --> 00:03:06,624
好吧。

47
00:03:06,880 --> 00:03:10,720
今天我们的系统有两个业务准则。第一个是

48
00:03:10,976 --> 00:03:15,584
我们最多只能预定火车总座位的70%。

49
00:03:17,120 --> 00:03:20,448
好这是第一个业务规准则。第二个是

50
00:03:20,704 --> 00:03:24,032
当我预定座位时，所有的座位要在同一个车厢。

51
00:03:24,288 --> 00:03:26,848
谁也不想家人朋友坐在

52
00:03:27,104 --> 00:03:29,920
不同的车厢。对吧？

53
00:03:30,176 --> 00:03:30,688
就这么简单。

54
00:03:30,944 --> 00:03:34,784
我们是从Emily Bache火车预订那里得到这些准则的。

55
00:03:35,296 --> 00:03:39,392
我们这还有一些用来实现这些规则的代码。

56
00:03:40,160 --> 00:03:46,304
我们的领域专家今天不能跟我们一起来到阿马斯特丹，不过前几周，

57
00:03:46,560 --> 00:03:47,840
我们和他谈了很多。

58
00:03:48,096 --> 00:03:49,632
他谈了很多火车相关的话题。

59
00:03:50,144 --> 00:03:53,984
他谈了火车ID、火车座位，

60
00:03:54,496 --> 00:03:55,264
火车车厢之类的。

61
00:03:56,288 --> 00:04:02,432
还谈了预定，还有这些预定有没有成功。

62
00:04:02,688 --> 00:04:06,784
如果我准备订票，还得有订票功能。

63
00:04:07,808 --> 00:04:09,600
我们之前已经解释了什么是订票单据。

64
00:04:10,368 --> 00:04:12,672
什么是预定，什么是预定失败。

65
00:04:13,184 --> 00:04:19,327
这是专家的用词。对，我们之前的交流，

66
00:04:19,583 --> 00:04:20,095
用的就是这些词。

67
00:04:22,399 --> 00:04:28,543
我们将会为一个名为Train Train的初创公司工作。他们提供

68
00:04:28,799 --> 00:04:32,127
座位预定服务，是个web API。

69
00:04:32,383 --> 00:04:36,479
这个web API还依赖于

70
00:04:36,735 --> 00:04:39,295
其他公司提供的后端支持。

71
00:04:39,807 --> 00:04:42,111
也就是SNCF。

72
00:04:42,367 --> 00:04:44,927
SNCF提供的第一个后端支持

73
00:04:45,439 --> 00:04:48,255
是Train Data。

74
00:04:48,767 --> 00:04:49,791
它就是一个

75
00:04:50,047 --> 00:04:51,327
火车拓扑服务。

76
00:04:51,583 --> 00:04:54,143
也就是说我们给他一个火车事件，

77
00:04:54,655 --> 00:04:56,959
我们可以就得到火车拓扑，比如

78
00:04:57,215 --> 00:05:03,359
所有的车厢，每一个车厢里的所有座位，每一个座位是可以预定的状态，

79
00:05:03,615 --> 00:05:04,639
还是已经被预定了。

80
00:05:05,919 --> 00:05:06,431
对，还有数量。

81
00:05:07,199 --> 00:05:13,343
第二个是订票单据。这个有点麻烦...也不麻烦

82
00:05:13,599 --> 00:05:14,623
当你买完票，你的火车票上就会有一个ID。

83
00:05:14,879 --> 00:05:21,023
就是这个意思。对。这就是一个只提供ID的服务。

84
00:05:21,279 --> 00:05:22,047
我们用它

85
00:05:22,303 --> 00:05:23,583
来订票。

86
00:05:24,095 --> 00:05:27,423
我们用它只是

87
00:05:27,679 --> 00:05:28,447
得到一个ID

88
00:05:29,215 --> 00:05:35,359
当左边的预定服务拿到火车拓扑后，我们就能找到可选的座位，

89
00:05:35,615 --> 00:05:36,127
然后

90
00:05:36,383 --> 00:05:39,199
可以拿到一个订票单据，我们其实是

91
00:05:39,711 --> 00:05:40,735
通过

92
00:05:40,991 --> 00:05:43,039
国家列车运营服务来订票的。

93
00:05:43,295 --> 00:05:45,855
就是通过最下面的这个火车订票服务。

94
00:05:46,367 --> 00:05:52,511
好吧？我们是一个初创公司，在这个刚开放的市场中

95
00:05:52,767 --> 00:05:58,655
还处于下游。这些后端的服务是国家列车运营服务提供的。

96
00:05:59,167 --> 00:06:00,447
到现在大家有什么问题吗？

97
00:06:01,727 --> 00:06:02,495
那我们继续。

98
00:06:03,519 --> 00:06:07,615
Bruno现在可以演示一下Web API。

99
00:06:10,175 --> 00:06:10,943
需要

100
00:06:11,199 --> 00:06:12,223
几秒钟

101
00:06:12,479 --> 00:06:13,247
才能转换屏幕。

102
00:06:16,575 --> 00:06:17,855
嗯

103
00:06:18,111 --> 00:06:19,903
我用的是postman，

104
00:06:20,159 --> 00:06:27,231
你可以看到我调用Web API时的url。

105
00:06:27,327 --> 00:06:29,375
我们还能看到请求体

106
00:06:29,631 --> 00:06:33,471
有两个值。

107
00:06:33,727 --> 00:06:36,031
Train_id是火车的ID。

108
00:06:36,287 --> 00:06:39,359
还有请求的座位数量number_of_seats。

109
00:06:40,127 --> 00:06:40,639
好

110
00:06:42,431 --> 00:06:43,711
如果你发送请求。

111
00:06:43,967 --> 00:06:45,247
没错。

112
00:06:45,759 --> 00:06:46,527
需要等一会。

113
00:06:50,367 --> 00:06:53,695
还在加载。好现在我们得到了响应。

114
00:06:53,951 --> 00:06:54,975
这就是响应。

115
00:06:55,231 --> 00:06:57,023
第一个是train_id。

116
00:06:57,535 --> 00:06:58,047
对吧？

117
00:06:58,303 --> 00:07:00,351
第二个是订票单据。

118
00:07:00,607 --> 00:07:03,423
是通过我们之前说的那个服务得到的。

119
00:07:03,679 --> 00:07:05,215
然后我们得到了

120
00:07:05,983 --> 00:07:11,031
座位的列表。

121
00:07:13,151 --> 00:07:17,503
好，我们的系统还挺简单的，对。

122
00:07:25,183 --> 00:07:30,559
不过我们有一个问题，这也是为什么我们今天在这里。

123
00:07:31,071 --> 00:07:35,935
Train Train公司找到我们，说一直都在面临着一个问题。

124
00:07:36,447 --> 00:07:41,311
国家列车运营服务给他们带来的问题。

125
00:07:42,079 --> 00:07:43,103
什么问题呢？

126
00:07:43,359 --> 00:07:44,383
每一次调用

127
00:07:44,895 --> 00:07:49,759
后端服务的时候，都是收费的。这对Train Train这个初创公司意味着

128
00:07:50,271 --> 00:07:55,647
每次调用这些web API都要钱。

129
00:07:55,903 --> 00:07:57,439
他们知道这些调用是要钱的，

130
00:07:57,695 --> 00:07:58,719
但是

131
00:07:59,231 --> 00:08:01,023
他们觉得还是太贵了。

132
00:08:01,279 --> 00:08:03,327
因此他们让我们来看一下代码。

133
00:08:03,583 --> 00:08:04,351
来看看

134
00:08:04,607 --> 00:08:08,447
到底是为什么，看看我们能不能找到它，如果有什么要修复的话，

135
00:08:08,703 --> 00:08:09,983
看看能不能修复。

136
00:08:11,519 --> 00:08:17,407
好吧？但是在我们着手遗留代码之前，如果你...
大家建议我和Bruno

137
00:08:19,455 --> 00:08:20,223
应该先干什么？

138
00:08:22,015 --> 00:08:23,807
（测试？）测试，没错。

139
00:08:24,319 --> 00:08:29,439
事实上，这就是我们错过主题演讲的原因。今天早上我们对此进行了一些测试。

140
00:08:30,207 --> 00:08:33,023
查看代码，试着凸显

141
00:08:33,279 --> 00:08:38,655
那些业务准则。到现在为止我们写了三个测试。

142
00:08:39,167 --> 00:08:44,543
第一个测试通过了。我们建了一个只有一个车厢

143
00:08:45,055 --> 00:08:49,151
一共10个座的火车。我们想预定3个座位。

144
00:08:49,407 --> 00:08:52,991
你看这就是我用postman做的，响应也都一样。

145
00:08:57,855 --> 00:08:59,391
通过。

146
00:09:00,159 --> 00:09:01,695
第二个测试是

147
00:09:02,207 --> 00:09:08,351
对这是第一个业务准则。我们对预定不能超过

148
00:09:08,607 --> 00:09:14,751
所有座位的70%。如果我们现在想预定2个座位，

149
00:09:15,007 --> 00:09:16,543
现在我们已经订出去了6个座位了，

150
00:09:17,567 --> 00:09:18,335
这里

151
00:09:19,871 --> 00:09:22,431
因为这个准则，

152
00:09:22,943 --> 00:09:28,831
70%也就是只有7个座位可以被预定。没错。所以是这么响应

153
00:09:29,343 --> 00:09:30,111
这个错误的。

154
00:09:30,623 --> 00:09:33,183
我能得到火车的ID，但是订票单据是空的。

155
00:09:33,439 --> 00:09:34,975
而且座位列表也是空的。

156
00:09:35,487 --> 00:09:38,047
用这种方式，Train Train告诉我们，我们没有

157
00:09:38,559 --> 00:09:40,095
预定任何座位。

158
00:09:41,375 --> 00:09:41,887
好。

159
00:09:42,143 --> 00:09:48,031
第三个测试是...所有的预定必须是在同一个车厢里。

160
00:09:48,543 --> 00:09:49,823
这是第二个业务准则。

161
00:09:50,079 --> 00:09:53,663
这种情况下我们找到了bug，因为我们这有

162
00:09:54,175 --> 00:10:00,319
一个两节车厢的火车。一节车厢基本上满了。

163
00:10:00,831 --> 00:10:03,135
另一节车厢完全是空的。当我们想订2个座位时，

164
00:10:03,647 --> 00:10:09,279
我们得到的是这个结果。两个车厢一边一个座位，这不是我们想要的，

165
00:10:09,535 --> 00:10:11,071
因为我们让家人朋友分开了。

166
00:10:11,839 --> 00:10:14,143
我们正在考虑的这个问题。Bruno说

167
00:10:15,423 --> 00:10:18,239
这结果也许解释了一些事。

168
00:10:18,495 --> 00:10:21,567
大家可能想到了这个结果会导致什么。

169
00:10:23,871 --> 00:10:25,407
试想你用

170
00:10:25,663 --> 00:10:26,431
网站订票

171
00:10:26,943 --> 00:10:28,223
你调用了后端的服务。

172
00:10:29,247 --> 00:10:31,039
你准备跟家人

173
00:10:31,295 --> 00:10:33,087
或者你的女朋友，男朋友

174
00:10:33,855 --> 00:10:35,391
一起旅行。

175
00:10:36,183 --> 00:10:40,183
会发生什么？（也许你就会取消这个预定了，因为你不能跟朋友坐一起了。）

176
00:10:41,279 --> 00:10:45,375
没错，这会导致人们取消预定。

177
00:10:45,631 --> 00:10:52,263
因为我可不想俩座位分别在俩车厢。我也许会取消了再订一次试试。

178
00:10:52,543 --> 00:10:57,663
取消重新订，再取消，再订，最后可能我就会换一个别的地方订票了。

179
00:10:57,919 --> 00:10:58,943
就不用Train Train了。

180
00:10:59,199 --> 00:11:00,479
因为用户体验太差。

181
00:11:00,735 --> 00:11:05,087
这也解释了为什么Train Train会觉得服务很贵，因为每一次预定都会被收费。

182
00:11:05,599 --> 00:11:08,671
这是我们的假设。

183
00:11:09,183 --> 00:11:12,511
我们跟领域专家讨论过。他说，是啊

184
00:11:12,767 --> 00:11:16,351
也许得找个新的方案，拜托

185
00:11:16,863 --> 00:11:18,399
你们要修好这个bug啊。

186
00:11:18,655 --> 00:11:23,519
所以，我们现在要一起修好这个bug。我们也会在这个过程中寻求大家的帮助。

187
00:11:25,055 --> 00:11:27,103
大家现在有什么建议吗？

188
00:11:27,359 --> 00:11:40,639
你们的策略是什么？（预定的那个服务是从Train Data那个服务拿数据吗？）

189
00:11:41,439 --> 00:11:47,327
我们是左边橙色的这个火车票预定服务。这个，我来...

190
00:11:49,119 --> 00:11:52,703
我们现在只管黄色的这个座位预定。

191
00:11:53,727 --> 00:11:59,055
这些都是依赖。我们其实没法控制。（是只有我们用这些服务吗？）

192
00:12:00,127 --> 00:12:06,271
不，我们和其他公司一起竞争。我们是一个初创公司，我们要跟别人竞争。

193
00:12:06,527 --> 00:12:11,391
我们需要从那俩服务获取信息，我们还得设置信息、确认信息、

194
00:12:11,647 --> 00:12:12,159
还要订票，

195
00:12:12,671 --> 00:12:14,463
用它来交易。

196
00:12:14,975 --> 00:12:15,487
所以

197
00:12:15,999 --> 00:12:17,279
这就是我们能做的操作。

198
00:12:19,327 --> 00:12:23,143
那现在还有什么建议吗？（写测试？）

199
00:12:23,679 --> 00:12:24,191
写测试。

200
00:12:24,447 --> 00:12:25,215
没错，写测试。

201
00:12:25,471 --> 00:12:31,615
其实我们已经写好了2个测试，来凸显这个bug。我们要修这个bug了。

202
00:12:33,663 --> 00:12:35,711
那我们看看代码吧。

203
00:12:35,967 --> 00:12:36,735
Bruno已经

204
00:12:37,247 --> 00:12:38,271
设了几个断点

205
00:12:39,807 --> 00:12:40,575
我们可以在这调用一下。没错，要等一小会儿。

206
00:12:43,135 --> 00:12:44,415
现在正在触发这个bug。

207
00:12:45,951 --> 00:12:47,743
这块，

208
00:12:48,255 --> 00:12:51,071
稍微向左移一下屏幕。

209
00:12:51,583 --> 00:12:56,447
这是个C#代码，用的是asp.net的API。

210
00:12:56,703 --> 00:13:02,847
这对于用Java Spring Boot的人来说比较简单。当我们用那个名字

211
00:13:03,103 --> 00:13:04,127
请求网络服务时

212
00:13:04,383 --> 00:13:07,455
我们可以得到响应。

213
00:13:08,479 --> 00:13:12,575
我们得到了ReservationRequestDto。

214
00:13:13,087 --> 00:13:18,975
看一下这个Dto，这个很简单，跟JSON完全一样。

215
00:13:19,743 --> 00:13:20,511
没错。

216
00:13:22,559 --> 00:13:28,703
然后我们安装了它，往左移一下屏幕，谢谢。你看我们安装了

217
00:13:28,959 --> 00:13:33,567
webTicketManager，是这个系统的入口。我们会调用

218
00:13:34,079 --> 00:13:35,103
它上面的预定方法。

219
00:13:35,359 --> 00:13:36,895
把train_id和预定的座位数当作参数。

220
00:13:38,943 --> 00:13:39,967
好了

221
00:13:40,735 --> 00:13:44,063
这就是我们目前的测试。

222
00:13:44,575 --> 00:13:47,135
我们可以看一下这些测试，这些挂了。

223
00:13:49,951 --> 00:13:50,719
我们一共有3个测试。

224
00:13:51,743 --> 00:13:54,815
这就像是异常测试，我们把这些当作black bug。

225
00:13:55,583 --> 00:13:59,167
如果我们发送这些请求，然后查看

226
00:14:00,703 --> 00:14:01,727
一下json数据

227
00:14:01,983 --> 00:14:03,775
最后一个测试，

228
00:14:04,031 --> 00:14:05,823
我们就可以看出这个问题。是吧？

229
00:14:06,079 --> 00:14:11,199
稍等，我们有一个工具。每当我们做改变的时候，

230
00:14:11,455 --> 00:14:17,599
我们输入一些东西，改变代码，它会在后台自动跑测试。

231
00:14:17,855 --> 00:14:23,999
然后左边会有有颜色的箭头，是给我们反馈。

232
00:14:24,255 --> 00:14:26,303
绿色代表没问题，红色

233
00:14:26,559 --> 00:14:30,399
代表有问题。这就有个红箭头。

234
00:14:30,911 --> 00:14:31,423
Bruno，你来...

235
00:14:31,679 --> 00:14:33,983
好我来展示。看看这个错误。

236
00:14:35,007 --> 00:14:39,103
这问题是，我们本来想要2个座位，

237
00:14:39,615 --> 00:14:42,431
1B和2B，但是我们得到的却是

238
00:14:42,943 --> 00:14:47,295
10A和1B。这是我们之前就讨论过的bug。

239
00:14:48,575 --> 00:14:50,111
对吧？

240
00:14:50,879 --> 00:14:57,023
我觉得现在最好停一下，我们再看看这个Reserve方法在干什么。

241
00:14:57,279 --> 00:15:01,119
我帮你找一下代码。

242
00:15:01,631 --> 00:15:07,519
我们先看一下。我们今天早上的时候看过了一次，所以

243
00:15:07,775 --> 00:15:12,383
我们可能更熟悉这段代码。我们会帮大家

244
00:15:12,639 --> 00:15:13,663
过一遍这代码。

245
00:15:14,431 --> 00:15:20,575
首先我们有一个可选座位的列表。这应该是

246
00:15:20,831 --> 00:15:22,367
这个方法的结果。

247
00:15:22,879 --> 00:15:25,695
然后我们调用trainDataService上的get train方法。

248
00:15:26,207 --> 00:15:32,351
我们就得到了jsonTrain这个数据。这也许是json拓扑，我们以后再看。

249
00:15:33,631 --> 00:15:39,751
然后我们就得到了train，一个火车拓扑。

250
00:15:40,287 --> 00:15:44,895
得到train之后，我们需要添加一些业务准则。

251
00:15:45,407 --> 00:15:51,551
如果被预定的座位数加上我想预定的座位数，

252
00:15:52,063 --> 00:15:53,087
低于

253
00:15:53,599 --> 00:15:56,159
低于GetMaxRes这个数，我看一下，

254
00:15:56,415 --> 00:16:00,511
应该是个百分数吧。对，70%。

255
00:16:01,023 --> 00:16:01,535
好。

256
00:16:01,791 --> 00:16:04,815
火车总座位数的70%。

257
00:16:04,863 --> 00:16:05,887
如果

258
00:16:06,143 --> 00:16:09,983
我们符合这个业务准则，那么我就可以继续。

259
00:16:10,751 --> 00:16:15,871
继续之后，numberOfReserv感觉像是个累加变量。

260
00:16:16,127 --> 00:16:18,431
我们想找到可选的座位。

261
00:16:19,199 --> 00:16:24,575
可选座位指的是系统里面BookingRef为空的座位。

262
00:16:25,087 --> 00:16:29,951
我们这有个属性，如果它为空的话，

263
00:16:30,463 --> 00:16:32,255
就代表这个座位可选。

264
00:16:32,511 --> 00:16:33,791
然后我们就可以把它加入到

265
00:16:34,047 --> 00:16:34,815
座位列表里。

266
00:16:35,071 --> 00:16:37,887
就是方法最后我们要返回的列表。

267
00:16:38,399 --> 00:16:39,679
到现在都还跟得上吧大家？

268
00:16:41,471 --> 00:16:46,079
然后这还有一些愚蠢的forEach，我们几年都没有看到过这个了。

269
00:16:46,335 --> 00:16:50,175
如果我们没有那么多可被预定的座位

270
00:16:50,943 --> 00:16:56,063
怎么办？我们会得到一个响应。

271
00:16:56,319 --> 00:16:59,135
告诉你不可以预定了。

272
00:16:59,647 --> 00:17:03,231
这个可是一个失败的消息啊。

273
00:17:03,743 --> 00:17:09,887
如果座位预定好了，我们会调用bookingReferenceService，就是在右边中间部分的这个。

274
00:17:10,911 --> 00:17:12,447
然后调用GetBookingReference。

275
00:17:13,983 --> 00:17:15,007
然后我们

276
00:17:15,263 --> 00:17:19,615
给每一个可预定的座位附上一个订票收据。

277
00:17:20,383 --> 00:17:21,151
到现在为止

278
00:17:21,407 --> 00:17:23,967
我们有很多的累加器。

279
00:17:24,479 --> 00:17:26,271
然后这里，又有一个

280
00:17:26,527 --> 00:17:32,671
跟之前基本一样的if。你看之前的。对确实像的。不对，第一个条件是不等。

281
00:17:32,927 --> 00:17:33,951
不完全一样。

282
00:17:34,207 --> 00:17:40,351
如果条件还满足的话...哦我们这还用了cache？是啊，有意思。

283
00:17:40,863 --> 00:17:42,399
我们等会再看看这是为什么，好吧？

284
00:17:42,655 --> 00:17:48,799
然后我们会干什么...这其实是在订票。

285
00:17:49,055 --> 00:17:49,567
其实就是交易。

286
00:17:49,823 --> 00:17:54,175
订票的话我们调用的是一个外部的web API。

287
00:17:54,687 --> 00:17:55,455
如果我

288
00:17:55,967 --> 00:17:56,991
进入这个的话

289
00:17:58,527 --> 00:17:59,295
我看一下

290
00:17:59,551 --> 00:18:01,343
here the implemetation.
这是它的实现。

291
00:18:01,599 --> 00:18:07,231
对我们就是调用了一个web API。

292
00:18:07,487 --> 00:18:09,399
有点意思。

293
00:18:09,535 --> 00:18:13,375
如果这没什么异常的话，

294
00:18:13,887 --> 00:18:16,447
我们会返回一个数据。

295
00:18:17,983 --> 00:18:21,567
返回值就是到目前为止我们找到的

296
00:18:22,079 --> 00:18:24,127
座位列表。都没什么问题吧？

297
00:18:24,639 --> 00:18:30,783
这里在干什么来着？哦对，如果预定座位数超过

298
00:18:31,039 --> 00:18:33,343
火车总座位数的话，

299
00:18:33,599 --> 00:18:38,719
我们返回一个空值。你就不能预定了。预定失败了。

300
00:18:39,743 --> 00:18:41,279
对吧？

301
00:18:42,559 --> 00:18:45,631
我们之后还会回过头再看一下这里，不过

302
00:18:45,887 --> 00:18:47,167
现在大家有什么

303
00:18:47,679 --> 00:18:49,703
疑问吗？

304
00:18:49,471 --> 00:18:54,971
（你们为什么用字符串连接来创建json？）

305
00:18:55,103 --> 00:18:57,919
我们为什么用字符串连接来创建json？

306
00:18:59,199 --> 00:19:00,479
其实这也不是我们自己写的代码。

307
00:19:00,735 --> 00:19:06,879
先声明一下，这是客户的代码，今天早上才成为我们客户的。不过你说的很对。我们为什么

308
00:19:09,695 --> 00:19:15,839
要在这里加json呢？这里应该是有一些

309
00:19:16,095 --> 00:19:17,119
业务逻辑吧。

310
00:19:19,935 --> 00:19:26,079
（用github link证明一下你刚才说的呗？） 我们在这个项目里都没用到git。

311
00:19:26,335 --> 00:19:34,151
我没法证明啊。（我觉得是不是应该把业务逻辑放在一个方法里啊？）

312
00:19:34,215 --> 00:19:35,807
没错。

313
00:19:36,063 --> 00:19:37,855
对，确实是。

314
00:19:38,367 --> 00:19:44,255
我们以后可以试试你的这个建议。我们会试着

315
00:19:45,791 --> 00:19:49,327
通过代码去了解火车领域的概念。

316
00:19:50,143 --> 00:19:55,775
我们试图弄清楚如何才能改进这个代码，因为到目前为止，有些东西真的挺让我烦恼的。

317
00:19:57,055 --> 00:20:00,347
我们刚才说的那个领域专家，

318
00:20:00,639 --> 00:20:02,687
跟我们讲理很多的概念。

319
00:20:03,967 --> 00:20:06,783
除了火车的概念

320
00:20:07,039 --> 00:20:10,367
座位的概念，你们还能看出

321
00:20:10,623 --> 00:20:12,991
其他的概念吗？

322
00:20:13,183 --> 00:20:16,463
有些东西是缺失的。（这没有车厢的概念。）

323
00:20:16,511 --> 00:20:19,839
没错，车厢的概念完全缺失了。

324
00:20:20,095 --> 00:20:22,631
其他的呢？（预定的概念？）

325
00:20:22,655 --> 00:20:27,775
预定，没错。到现在为止，没有预定的概念。

326
00:20:28,031 --> 00:20:30,591
大家谁之前有看过类似这样的代码？

327
00:20:32,127 --> 00:20:33,151
看来有人遇到过啊。

328
00:20:34,943 --> 00:20:41,087
看来并不是只有我们遇到了这个问题。对所有在座的人来说，今天我们要找出一个方式

329
00:20:41,343 --> 00:20:42,111
来改进这个代码。

330
00:20:42,367 --> 00:20:43,135
因为

331
00:20:43,391 --> 00:20:46,463
因为现在我们这没有指导，

332
00:20:46,719 --> 00:20:52,559
我们来修bug的策略就是先看懂它。

333
00:20:52,863 --> 00:20:54,655
但在那之前，

334
00:20:54,911 --> 00:20:57,471
这有好多糟糕的代码啊。

335
00:20:57,727 --> 00:20:59,007
我们先清理一下。

336
00:20:59,263 --> 00:21:00,799
先Clean the deck？是的。

337
00:21:01,055 --> 00:21:03,103
你们知道Clean the deck是什么吗？

338
00:21:03,359 --> 00:21:04,895
Clean the deck这种说法？不知道？

339
00:21:05,407 --> 00:21:06,943
Clean the deck

340
00:21:07,455 --> 00:21:10,527
是你检测代码的第一步

341
00:21:10,783 --> 00:21:14,367
因为在做深度重构之前，你必须

342
00:21:14,623 --> 00:21:18,208
让自己更有信心。

343
00:21:18,464 --> 00:21:23,280
这是检测代码的一种方式，从小的地方去修复代码，

344
00:21:24,096 --> 00:21:25,888
就比如变量名字啊。

345
00:21:26,656 --> 00:21:27,424
这之后，

346
00:21:28,192 --> 00:21:34,336
再继续编程。是的，这就是我们在脑海里准备一个心理模型的方式。

347
00:21:35,992 --> 00:21:40,736
好那我们回到刚才，开始Clean the deck。大家一点一点的去改进，

348
00:21:40,992 --> 00:21:42,272
就会有一个新的理解。

349
00:21:42,528 --> 00:21:45,344
稍等，我看有人有问题。

350
00:21:47,392 --> 00:21:53,024
（你63行有个拼写错误。） 63行有个错？哦对，没错。这就是遗留代码啊。

351
00:21:54,560 --> 00:21:56,864
不过你注意到了没有这里有点问题？我们得修复它。

352
00:21:57,888 --> 00:21:58,912
这红了。

353
00:21:59,424 --> 00:22:00,704
如果我们代码红了，

354
00:22:01,472 --> 00:22:05,568
我很难有信心去修改它。因为如果

355
00:22:05,824 --> 00:22:06,592
改的时候出错了，

356
00:22:07,104 --> 00:22:10,176
我根本不知道出错了。我还是更喜欢看到这里的代码

357
00:22:10,688 --> 00:22:11,968
都是绿色的。

358
00:22:12,480 --> 00:22:13,248
为了让它变绿，

359
00:22:14,016 --> 00:22:17,600
我们要完全忽略这个测试，先去找bug。

360
00:22:18,112 --> 00:22:19,136
这是一个很好的技巧

361
00:22:19,392 --> 00:22:22,720
如果你也面临着测试挂了的这种情况，

362
00:22:23,488 --> 00:22:26,304
你需要先重构再修bug，

363
00:22:26,816 --> 00:22:30,400
你最好就先忽略那个测试。

364
00:22:30,656 --> 00:22:36,800
现在变绿了，我们这也还有一个测试。我们可以先重构，然后启用这个测试，再去修复bug。

365
00:22:37,568 --> 00:22:39,080
这其实就是

366
00:22:39,360 --> 00:22:40,896
你现在做的。白色

367
00:22:41,152 --> 00:22:50,784
意味着我们不跑这个测试。现在我就可以开始了。（我有个问题。如果我们

368
00:22:51,392 --> 00:22:51,904
新建一个测试，来测试当前的行为，

369
00:22:56,000 --> 00:22:57,024
是不是更好？

370
00:22:58,560 --> 00:23:00,608
因为当你重构的时候，你还是想

371
00:23:02,144 --> 00:23:04,192
保留当前的行为的。）是的。

372
00:23:05,216 --> 00:23:09,568
（新建一个测试的话，我们忽略掉旧的测试。）没错。（新建的测试就测

373
00:23:12,128 --> 00:23:13,664
当前的行为，我们得通过这个新测试才行。）

374
00:23:15,200 --> 00:23:19,552
是的，这是Golden master，是我很喜欢的一个技巧。

375
00:23:20,064 --> 00:23:21,856
Golden master是你拿到一个遗留代码，

376
00:23:22,368 --> 00:23:23,136
复制这个代码，

377
00:23:23,648 --> 00:23:27,232
然后去写验收测试。

378
00:23:27,488 --> 00:23:34,632
每当我将输入发送到遗留代码和新写的代码时，

379
00:23:34,656 --> 00:23:37,216
我得到的两个输出

380
00:23:37,472 --> 00:23:39,264
应该一样。

381
00:23:39,520 --> 00:23:40,800
所以即使

382
00:23:41,056 --> 00:23:43,616
不知道代码的上下文，

383
00:23:43,872 --> 00:23:45,152
我依然可以有这个测试。

384
00:23:45,408 --> 00:23:50,528
这也强迫我，不要影响现有的行为。

385
00:23:51,040 --> 00:23:57,184
我们本来应该这么做的，不过现在我们在实现业务准则，

386
00:23:57,440 --> 00:23:58,976
所以作为领域专家，

387
00:23:59,488 --> 00:24:05,632
我们就先用现有的代码。不过你说的那个确实是重构的好方法。

388
00:24:07,168 --> 00:24:08,704
Bruno，继续clean the deck吧。

389
00:24:08,960 --> 00:24:10,752
我们可以看到，

390
00:24:11,776 --> 00:24:17,056
这第一个变量，seat。

391
00:24:17,920 --> 00:24:20,444
我要看一下

392
00:24:20,736 --> 00:24:23,808
在哪用了它。离调用的地方很远啊。是啊，确实远。

393
00:24:24,576 --> 00:24:25,088
那...

394
00:24:26,880 --> 00:24:27,904
也许

395
00:24:29,952 --> 00:24:32,768
我可以把它移的

396
00:24:33,280 --> 00:24:35,328
离调用的地方近一点的。

397
00:24:37,632 --> 00:24:40,704
比如放这。后面的人你们看得到所有的代码吗？

398
00:24:40,960 --> 00:24:47,104
我的测试是实时运行的，所以我知道我没有破坏现有的代码。这都是绿色的。

399
00:24:48,896 --> 00:24:55,040
我是个C语言程序员，C语言的程序员一般习惯

400
00:24:55,296 --> 00:24:58,112
把所有变量都写在代码的最前面。

401
00:24:58,368 --> 00:24:59,904
所以这是你写的代码？

402
00:25:00,160 --> 00:25:06,304
不，不是我写的。好，第二个变量是count。

403
00:25:07,840 --> 00:25:10,656
count，这名字起的。

404
00:25:11,424 --> 00:25:12,448
是啊，count。

405
00:25:13,984 --> 00:25:17,568
这又是个愚蠢的循环。是啊，我们在list里循环。

406
00:25:17,824 --> 00:25:19,872
这其实是count的list。

407
00:25:20,128 --> 00:25:22,432
完全是一样的数字啊。

408
00:25:22,688 --> 00:25:28,832
这有个提示，这个没被用过。它是不是想告诉我们点什么？

409
00:25:29,392 --> 00:25:34,208
我应该可以用

410
00:25:34,720 --> 00:25:35,488
availabelSeats

411
00:25:35,744 --> 00:25:36,512
赋值给count。

412
00:25:36,768 --> 00:25:40,864
对，因为这个循环最后，count和availableSeats的值

413
00:25:41,120 --> 00:25:43,680
是一样的。我现在可以删了这个。

414
00:25:43,936 --> 00:25:44,448
好了。

415
00:25:45,216 --> 00:25:46,240
好，就先这样。

416
00:25:46,496 --> 00:25:50,848
现在，我们可以看一下，这方法占几个屏幕。

417
00:25:51,616 --> 00:25:52,640
一，二

418
00:25:53,664 --> 00:25:54,176
两个

419
00:25:54,432 --> 00:25:56,736
两个半？对，两个半。

420
00:25:57,504 --> 00:26:00,576
这其实也是另一个困扰我的事情，方法太长了。

421
00:26:01,344 --> 00:26:02,112
好吧。

422
00:26:03,392 --> 00:26:10,536
好，这是火车拓扑的代码。

423
00:26:11,072 --> 00:26:12,352
没准我们可以重命名？

424
00:26:14,400 --> 00:26:15,424
可以啊。

425
00:26:15,680 --> 00:26:16,192
Train topology?

426
00:26:16,448 --> 00:26:17,216
嗯可以。

427
00:26:17,472 --> 00:26:23,616
Traintopol然后...拓扑这个词挺好，我们刚才一直都在说

428
00:26:23,872 --> 00:26:30,016
火车拓扑嘛。对，确实比之前那个好。那这个词，trainInst。

429
00:26:30,528 --> 00:26:32,320
指令？还是实例？

430
00:26:32,832 --> 00:26:37,952
我们问了领域专家，他说领域里没有火车实例的概念。

431
00:26:38,464 --> 00:26:44,352
所以这个可能是train install？那我把它改成train吧。所以现在我们从火车拓扑，得到一个火车。不错。

432
00:26:45,632 --> 00:26:48,192
这是什么？

433
00:26:48,448 --> 00:26:52,032
numberOfReserv。也许你应该

434
00:26:52,288 --> 00:26:57,152
把它放这边，这样后面的人能看清所有的代码。好的，你们看这个。

435
00:26:58,944 --> 00:27:02,272
numberOfReserv。这个被用过吗？没有吧？。

436
00:27:03,040 --> 00:27:05,088
这就是个形式而已啊。

437
00:27:05,344 --> 00:27:09,696
我们这个变量

438
00:27:09,952 --> 00:27:16,096
没有什么用。只是为了计算，以防我们的计数是错的。

439
00:27:16,352 --> 00:27:19,936
也许这个是故意的？我也不知道。

440
00:27:20,192 --> 00:27:24,776
我们其实不用去理解这个。这些乱七八糟的。

441
00:27:26,848 --> 00:27:29,408
好，我可以把这个删了。

442
00:27:29,664 --> 00:27:32,480
那你不要这个了？对不要了。

443
00:27:35,040 --> 00:27:35,808
那你可以删了它。

444
00:27:36,064 --> 00:27:36,576
是的。

445
00:27:36,832 --> 00:27:42,976
呃...这个each

446
00:27:43,232 --> 00:27:47,840
应该是seat。对，从seat的collection中我们得到的是seat。

447
00:27:48,608 --> 00:27:53,216
这有个小错误，应该是reservedSet。

448
00:27:53,728 --> 00:27:59,872
我们没有集合的概念。我们问过领域专家到底有没有集合的概念？他们说没有。这又有一个循环。

449
00:28:03,968 --> 00:28:04,992
但是没被用过。

450
00:28:06,272 --> 00:28:07,808
谁之前也在代码里遇见过这种

451
00:28:08,064 --> 00:28:13,696
根本没被用过的变量、声明之类的？

452
00:28:14,976 --> 00:28:16,512
对。遗留代码里

453
00:28:16,768 --> 00:28:18,280
很多这种东西。

454
00:28:18,816 --> 00:28:21,376
这有点污染我们的头脑。

455
00:28:23,424 --> 00:28:24,704
这个。

456
00:28:24,960 --> 00:28:27,008
看看这个。我们这有

457
00:28:29,056 --> 00:28:32,896
一个if。然后我们在这又有一个差不多的if。

458
00:28:34,176 --> 00:28:35,200
是，那我...

459
00:28:35,456 --> 00:28:44,600
我们喜欢对称性，这有利于我们去相互比较。为了这么做，我们建议把第一个if逻辑反转一下。对这是个好主意。

460
00:28:44,928 --> 00:28:47,232
反转这个if逻辑。然后

461
00:28:47,488 --> 00:28:50,304
你看这些都差不多一样...

462
00:28:51,328 --> 00:28:53,632
我要选中...等一下

463
00:28:53,888 --> 00:28:54,656
我们看一下。

464
00:28:56,192 --> 00:28:58,752
这，你看有一个if。这里。

465
00:29:00,032 --> 00:29:02,080
这又有一个差不多的。

466
00:29:02,592 --> 00:29:08,224
因为中间什么也没有，我们可以把下面if里的代码剪切，

467
00:29:08,480 --> 00:29:11,552
粘贴到第一个if到后面。

468
00:29:11,808 --> 00:29:14,880
这个，就在它后面，这样也符合算法逻辑。

469
00:29:16,928 --> 00:29:17,440
然后

470
00:29:18,976 --> 00:29:22,560
这也会简化一点代码结构。

471
00:29:22,816 --> 00:29:26,912
这确实不错。都是绿的你看。

472
00:29:27,936 --> 00:29:28,448
现在我们可以...看一下

473
00:29:28,704 --> 00:29:34,848
你为什么那么做？因为，它是白色的。对，当代码

474
00:29:35,104 --> 00:29:36,640
没被覆盖，

475
00:29:38,432 --> 00:29:38,944
这会有一个白色的

476
00:29:39,200 --> 00:29:40,480
标识符

477
00:29:41,248 --> 00:29:42,016
这对我们来说

478
00:29:42,528 --> 00:29:45,600
挺好的。这个也没有什么必要。

479
00:29:48,160 --> 00:29:50,464
对你可以把这几行删了。

480
00:29:50,720 --> 00:29:52,256
我觉得我们

481
00:29:52,512 --> 00:29:58,144
有些空行？对，也许这个可以离用它的地方更近一点。

482
00:29:58,912 --> 00:29:59,936
好

483
00:30:01,472 --> 00:30:02,496
好，你现在

484
00:30:03,008 --> 00:30:06,848
把声明和调用放一起了。目前还不完美，但是

485
00:30:07,360 --> 00:30:09,408
我们至少做了一些改变。

486
00:30:09,920 --> 00:30:14,272
改的不多。这不是一个完全的重构。这只是让我们更自信。

487
00:30:14,528 --> 00:30:17,344
如果我们想完善心理模型，

488
00:30:17,600 --> 00:30:20,416
并清理一下代码，

489
00:30:20,928 --> 00:30:22,976
这只是第一步。
